
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Módulo de Indicaciones Médicas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería Sortable.js para la funcionalidad de arrastrar y soltar -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
	<!-- Librería FloatingUI.js para la funcionalidad de elementos "flotantes" -->
	<script src="https://cdn.jsdelivr.net/npm/@floating-ui/core@1.6.0"></script>
	<script src="https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.6.3"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        /* 1. Variables de Color (Máxima Escalabilidad) */
		:root {
			--popover-bg: white;
			--popover-border-color: #e5e7eb; /* gray-200 */
			--tooltip-bg: rgba(31, 41, 55, 0.95);
		}
		body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Clase para el "handle" de arrastre que cambia el cursor */
        .drag-handle {
            cursor: grab;
        }
        /* Estilos para el elemento fantasma de Sortable.js */
        .sortable-ghost {
            opacity: 0.2;
        }
        .radio-route-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.125rem;
        }
        .radio-route-group input[type="radio"] {
            display: none;
        }
        .radio-route-group label {
            padding: 0.0625rem 0.25rem;
            border-radius: 9999px;
            font-size: 0.625rem;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid #d1d5db;
            color: #4b5563;
            background-color: #f9fafb;
            transition: all 0.2s;
        }
        .radio-route-group input[type="radio"]:checked + label {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
        }
		#info-modal {
			z-index: 100;
		}
		#reason-modal {
			z-index: 90; /* Estará por debajo del info-modal, pero por encima del resto */
		}
		/* El modal de confirmación de hora va debajo */
		#confirm-hour-modal {
		    z-index: 90;
		}
		
		/* El modal de corrección va debajo */
		#correction-modal {
		    z-index: 90;
		}
		
		/* El modal de historial SOS va debajo */
		#sos-history-modal {
		    z-index: 90;
		}
		#edit-schedule-modal {
			z-index: 90;
		}
		#bulk-modal {
			z-index: 90;
		}
        /* Estilos para el pop-over */
        .schedule-popover {
            position: absolute;
            z-index: 60;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease-in-out;
            transform-origin: top center;
            width: 280px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 1rem;
        }
        .schedule-popover.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
		/* Contenedor de la flecha (posicionado por Floating UI) */
		.popover-arrow, .tooltip-arrow {
			position: absolute;
			width: 16px;
			height: 8px;
			line-height: 0;
		}
		/* 2. Estructura Base del Contenedor de la Flecha */
		.arrow-container {
			position: absolute;
			width: 16px;
			height: 8px;
			line-height: 0;
		}
		.arrow-svg {
			display: block;
			width: 100%;
			height: 100%;
		}
		/* 3. Estilos de los Paths del SVG */
		.arrow-stroke, .arrow-fill {
			stroke-width: 1px; /* Un grosor de 1px es más nítido */
			stroke: transparent; /* ¡CORRECCIÓN! Por defecto, todos los bordes son transparentes */
			fill: none; /* ¡CORRECCIÓN! Por defecto, no hay relleno */
		}
		/* 4. Estilos Específicos para la Flecha del POPOVER */
		#schedule-popover .arrow-stroke {
			fill: var(--popover-border-color); /* ¡CORRECCIÓN! Usamos 'fill' para el borde */
		}
		#schedule-popover .arrow-fill {
			fill: var(--popover-bg); /* El relleno blanco se mantiene */
		}
		/* 5. Estilos Específicos para la Flecha del TOOLTIP */
		#tooltip .arrow-stroke {
			fill: transparent; /* Aseguramos que el borde sea invisible */
		}
		#tooltip .arrow-fill {
			fill: var(--tooltip-bg); /* El relleno del color del tooltip se mantiene */
		}
		/* 6. Lógica de Posicionamiento y Rotación */
		[data-popper-placement^='bottom'] > .arrow-container {
			top: -8px; /* Coincide con la altura del SVG */
		}
		[data-popper-placement^='top'] > .arrow-container {
			bottom: -8px; /* Coincide con la altura del SVG */
			transform: rotate(180deg);
		}
        #tooltip {
            position: absolute;
            z-index: 100;
            background-color: rgba(31, 41, 55, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            max-width: 250px;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
			top: 0;
			left: 0;
        }
        #tooltip.visible {
            opacity: 1;
            visibility: visible;
        }
		.tooltip-wrapper {
		    position: relative; /* Necesario para posicionar el pseudo-elemento */
		    display: inline-block; /* Asegura que el wrapper tenga dimensiones */
		}
		
		/* Creamos una capa invisible y más grande sobre el wrapper */
		.tooltip-wrapper::before {
		    content: '';
		    position: absolute;
		    /* Hacemos la capa un poco más grande que el ícono para un área de activación cómoda */
		    top: -4px;
		    left: -4px;
		    right: -4px;
		    bottom: -4px;
		    /* background-color: rgba(255, 0, 0, 0.2); /* Descomenta esta línea para ver el área de activación */
		}
		
        /* Estilos para el botón de razón seleccionado */
        .reason-button.selected {
            background-color: #dbeafe; /* bg-blue-100 */
            border-color: #93c5fd; /* border-blue-300 */
            font-weight: 600; /* font-semibold */
            color: #1e40af; /* text-blue-800 */
        }

        /* Clase para la indicación suspendida */
        .suspended-indication {
            <!-- filter: grayscale(1); /* Fila en escala de grises */ -->
            background-color: #f3f4f6; /* Fondo gris claro */
            color: #9ca3af; /* Color de texto gris */
            font-style: italic; /* Tipografía diferente: cursiva */
        }
        /* Estilos para los botones de horario en escala de grises */
        .grayscale-filter {
            filter: grayscale(100%);
            opacity: 0.5;
            border-color: transparent !important;
        }

        /* Nueva clase para botones no clicables que permite el tooltip */
        .non-clickable {
            /* La siguiente línea es clave para que los eventos de mouse sigan funcionando en el padre */
            /* pointer-events: none;  -- se ha removido para que el mouseover funcione */
        }
        
        /* Etiqueta de estado para la Opción 1 */
        .status-badge {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            background-color: #e5e7eb;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            margin-left: 0.5rem;
            white-space: nowrap;
        }
		.visible {
			opacity: 1;
			visibility: visible;
		}
		/* Estilos para el Toast de Confirmación */
		.toast {
			position: fixed;
			bottom: 1.5rem;
			right: 1.5rem;
			background-color: rgba(17, 24, 39, 0.9); /* bg-gray-900 con opacidad */
			color: white;
			padding: 0.75rem 1.25rem;
			border-radius: 9999px; /* rounded-full */
			font-size: 0.875rem; /* text-sm */
			z-index: 100;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s ease-in-out, bottom 0.3s ease-in-out;
		}
		.toast.show {
			opacity: 1;
			visibility: visible;
			bottom: 2.5rem;
		}
		
		/* Estilo para la sección de indicaciones en modo edición de enfermera */
		.nurse-editing-mode {
			outline: 2px solid #60a5fa; /* border-blue-400 */
			border-radius: 0.5rem;
			box-shadow: 0 0 0 4px rgba(96, 165, 250, 0.2);
			transition: all 0.2s ease-in-out;
		}

		/* Estilo para los botones de horario deshabilitados en modo edición */
		.schedule-button.disabled-in-edit {
		    background-color: #e5e7eb; /* gray-200 */
		    color: #9ca3af; /* gray-400 */
		    cursor: not-allowed;
		    position: relative; /* Necesario para el posicionamiento del pseudo-elemento */
		}
		.schedule-button.disabled-in-edit::after {
		    content: '🔒';
		    position: absolute;
		    /* ¡LÓGICA CORREGIDA! Posicionamos en la esquina superior derecha. */
		    top: -6px;
		    left: -6px;
		    font-size: 11px;
		    background-color: white;
		    border-radius: 9999px; /* Círculo completo */
		    padding: 2px;
		    line-height: 1; /* Asegura que el padding sea consistente */
		    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
		    border: 1px solid #f3f4f6; /* Borde sutil */
		}

		/* Estilo para los botones de horario editables en modo edición */
		.schedule-button.editable-in-edit {
			position: relative;
		}
		.schedule-button.editable-in-edit::after {
		    content: ''; /* El contenido ahora es el background-image */
		    /* ¡SVG DEL LÁPIZ! */
		    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%230ea5e9" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>');
		    background-repeat: no-repeat;
		    background-position: center;
		    background-size: 10px 10px; /* Ajusta el tamaño del ícono dentro del círculo */
		    position: absolute;
		    /* ¡LÓGICA CORREGIDA! Posicionamos arriba y al centro. */
		    top: -9px; /* Empuja el ícono hacia arriba, fuera del botón */
		    left: 50%; /* Mueve el borde izquierdo del ícono al centro del botón */
		    transform: translateX(-50%); /* Centra el ícono perfectamente */
		    background-color: white;
		    border-radius: 50%;
		    width: 18px;  /* Tamaño del círculo contenedor */
		    height: 18px; /* Tamaño del círculo contenedor */
		    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
		    border: 1px solid #e5e7eb; /* Borde sutil */
		}

		/* Banner de edición de la enfermera */
		#nurse-draft-banner {
			background-color: #eff6ff; /* bg-blue-50 */
			border-color: #bfdbfe; /* border-blue-200 */
		}
		#nurse-draft-banner span {
			color: #1e40af; /* text-blue-800 */
		}
		#nurse-draft-banner svg {
			color: #2563eb; /* text-blue-600 */
		}
		/* Estilo para la fila "sucia" (modificada) en modo edición de enfermera */
		.nurse-editing-mode .pharma-row.dirty {
			background-color: #eff6ff; /* bg-blue-50 */
		}
		.correction-status-button.selected {
		    border-color: #3b82f6; /* border-blue-500 */
		    background-color: #eff6ff; /* bg-blue-50 */
		    box-shadow: 0 0 0 1px #3b82f6;
		}
		.correction-reason-button.selected {
		    background-color: #dbeafe; /* bg-blue-100 */
		    border-color: #93c5fd; /* border-blue-300 */
		    font-weight: 600; /* font-semibold */
		    color: #1e40af; /* text-blue-800 */
		}
    </style>
</head>
<body class="bg-gray-50 text-gray-900">

    <!-- Main Container -->
    <div id="app" class="min-h-screen relative">
        <!-- Header -->
        <div class="bg-white border-b border-gray-200 px-4 py-3 sticky top-0 z-10">
            <div class="flex justify-between items-center mb-2">
                <div>
                    <h1 class="text-base font-bold text-gray-900">Indicaciones Médicas</h1>
                    <p class="text-sm text-gray-600">
                        <strong>Paciente:</strong> María G. | <strong>RUT:</strong> 12.345.678-9 |
                        <strong>Edad:</strong> 65 años | <strong>Alergias:</strong> Penicilina
                    </p>
                </div>
                <div class="flex items-center gap-1">
                    <div class="flex items-center gap-1">
                        <label for="role-select" class="text-sm font-medium text-gray-700">Ver como:</label>
                        <select id="role-select" class="border border-gray-300 rounded-md px-2 py-0.5 text-sm">
                            <option value="medico">Médico</option>
                            <option value="enfermera">Enfermera</option>
                            <option value="tens">TENS</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Date Navigation -->
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <button id="prev-day" class="flex items-center gap-1 px-2 py-1 text-gray-600 hover:text-gray-900">
                        <!-- Icono ChevronLeft -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>
                        Día Anterior
                    </button>
                    <span id="current-date-display" class="font-medium text-gray-900 text-sm"></span>
                    <button id="next-day" class="flex items-center gap-1 px-2 py-1 text-gray-600 hover:text-gray-900">
                        Día Siguiente
                        <!-- Icono ChevronRight -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>
                    </button>
                </div>

                <button id="action-button" class="px-3 py-1.5 rounded-md font-medium text-sm"></button>
				<button id="new-sheet-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 hidden">Nueva Hoja</button>
            </div>

            <!-- Banner de Borrador -->
            <div id="draft-banner" class="mt-2 p-1.5 bg-yellow-50 border border-yellow-200 rounded-md flex items-center gap-2 hidden">
                <!-- Icono AlertTriangle -->
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-triangle text-yellow-600"><path d="m21.73 18-9-15-9 15h18Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>
                <span class="text-sm text-yellow-800">Hay cambios pendientes sin autorizar</span>
            </div>
			<!-- Banner de Borrador para Enfermera -->
			<div id="nurse-draft-banner" class="mt-2 p-1.5 border rounded-md flex items-center gap-2 hidden">
				<!-- Icono Pencil -->
				<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>
				<span class="text-sm">Modo de edición de horarios activado. Tienes cambios sin guardar.</span>
			</div>
        </div>

        <div class="p-4 space-y-3">
            <!-- Sección de Indicaciones Generales -->
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-3">
                <h2 class="text-sm font-semibold text-gray-900 mb-2">Indicaciones Generales</h2>
                <div id="general-indications-form" class="grid grid-cols-2 sm:grid-cols-4 gap-x-3 gap-y-2">
                    <!-- Los inputs de indicaciones generales se renderizarán aquí -->
                </div>
            </div>

            <!-- Contenedor Flex para la Opción B: Principal (70%) y Sidebar (30%) -->
            <div class="flex flex-col lg:flex-row gap-3">
            <!-- Columna Principal: Indicaciones Farmacológicas + Pendientes -->
            <div class="lg:w-7/12 space-y-3">
                <!-- Sección de Indicaciones Farmacológicas -->
                <section class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="p-3 border-b border-gray-200">
                        <div class="flex justify-between items-center">
                            <h2 class="text-sm font-semibold text-gray-900">Indicaciones Farmacológicas</h2>
                        </div>
                    </div>

                    <div class="overflow-x-auto overflow-y-visible">
                        <table class="w-full">
							<thead id="pharma-table-head"></thead>
							<tbody id="pharmacological-indications-table" class="divide-y divide-gray-200"></tbody>
						</table>
						<!-- Footer -->
						<div id="pharma-footer" class="">
							<!-- Tabla de Footer -->
							<table class="w-full">
								<tbody id="pharma-footer-table" class="border-t border-b border-gray-200">
									<tr id="ghost-row" class="text-sm"> 
					                    <td class="px-3 py-1.5 w-8 text-gray-400">–</td>
					                    <td class="px-2 py-1.5">
					                        <textarea id="ghost-textarea" class="w-full border-0 focus:ring-0 focus:border-0 bg-transparent text-sm font-medium py-1 resize-none overflow-hidden" rows = "1" placeholder="Nueva indicación..."></textarea>
					                    </td>
					                    <td class="px-2 py-1.5"></td>
					                    <td class="px-2 py-1.5 w-60"></td>
					                    <td class="px-2 py-1.5 w-8 text-gray-400">–</td>
									</tr>
								</tbody>
							</table>
							<div id="boton-footer" class="flex items-center justify-start pl-3 gap-2 mb-3">
								<!-- Botón principal Agregar -->
								<button id="add-new-indication" class="flex items-center gap-2 px-3 py-1.5 text-blue-600 hover:bg-blue-50 rounded-md hidden">
									<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
									<span class="text-sm">Agregar</span>
								</button>
								
								<!-- Botón flecha y menú para "Agregar múltiples" -->
								<div id="add-multiple-container" class="relative inline-block">
									<button id="add-multiple-toggle" class="px-3 py-1.5 text-blue-600 hover:bg-blue-50 rounded-md hidden" aria-haspopup="true" aria-expanded="false" title="Más opciones">
										<!-- Icono Chevron Right -->
										<svg xmlns="http://www.w3.org/2000/svg" class="lucide lucide-chevron-right" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
											<path d="m9 18 6-6-6-6"/>
										</svg>
									</button>
								
									<div id="add-multiple-menu" class="absolute left-full top-0 ml-2 w-40 bg-white border border-gray-200 rounded-md shadow-lg z-20 hidden">
										<button id="open-bulk-modal" class="w-full text-left px-3 py-2 hover:bg-gray-50 text-sm">Agregar múltiples</button>
									</div>
								</div>
							</div>
						</div>
                    </div>
                </section>

                <!-- Sección Pendientes de Revisión -->
                <section id="pending-review-section" class="bg-white rounded-lg shadow-sm border border-gray-200 hidden">
                    <div class="p-3 border-b border-gray-200">
                        <h3 class="text-sm font-semibold text-gray-900">Indicaciones pendientes de revisión</h3>
                    </div>
                    <div class="p-3">
                        <div id="pending-review-list" class="space-y-2"></div>
                    </div>
                </section>
            </div>
                
                <!-- Columna de Barra Lateral (Indicaciones Verbales) -->
                <div class="lg:w-5/12 space-y-3">
                    <!-- Sección de Indicaciones Verbales Pendientes -->
                    <div id="verbal-indications-section" class="bg-white rounded-lg shadow-sm border border-gray-200 p-3 hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <!-- Icono AlertTriangle -->
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-triangle text-amber-500"><path d="m21.73 18-9-15-9 15h18Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>
                            <h2 class="text-sm font-semibold text-gray-900">Indicaciones Verbales por Validar</h2>
                        </div>
                        <div id="verbal-indications-list" class="space-y-1">
                            <!-- Las indicaciones verbales se renderizarán aquí -->
                        </div>
                    </div>

                    <!-- Nueva Sección para Indicaciones Verbales Procesadas -->
                    <div id="processed-verbal-section" class="bg-white rounded-lg shadow-sm border border-gray-200 p-3 hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <!-- Icono FileText -->
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text text-gray-500"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                            <h2 class="text-sm font-semibold text-gray-900">Indicaciones Verbales Procesadas</h2>
                        </div>
                        <div id="processed-verbal-list" class="space-y-1">
                            <!-- Las indicaciones verbales procesadas se renderizarán aquí -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal de Confirmación para Suspender Indicación -->
    <div id="confirm-suspend-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-60 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-bold text-gray-900 mb-2">Confirmar Suspensión</h3>
            <p class="text-sm text-gray-600 mb-4">¿Estás seguro de que quieres suspender esta indicación? Esta acción no se puede deshacer una vez autorizada.</p>
            <div class="flex justify-end gap-3">
                <button id="cancel-suspend-button" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cancelar</button>
                <button id="confirm-suspend-button" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium">Suspender</button>
            </div>
        </div>
    </div>
	
	<!-- Modal de Información Genérico -->
	<div id="info-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
			<div class="flex items-start gap-4">
				<!-- Contenedor del Ícono -->
				<div id="info-modal-icon" class="flex-shrink-0 mt-1">
					<!-- El ícono se insertará aquí con JS -->
				</div>
				<div>
					<h3 id="info-modal-title" class="text-lg font-bold text-gray-900"></h3>
					<p id="info-modal-message" class="text-sm text-gray-600 mt-1"></p>
				</div>
			</div>
			<div class="mt-5 flex justify-end">
				<button id="info-modal-close-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Entendido</button>
			</div>
		</div>
	</div>
	<!-- Modal de Confirmación de Hora Ambigüa -->
	<div id="confirm-hour-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
			<div class="flex items-start gap-4">
				<div>
					<h3 id="confirm-hour-title" class="text-lg font-bold text-gray-900">Confirmar Horario</h3>
					<p id="confirm-hour-message" class="text-sm text-gray-600 mt-2"></p>
				</div>
			</div>
			<div class="mt-5 flex justify-end gap-3">
				<button id="confirm-hour-today-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Usar para Hoy</button>
				<button id="confirm-hour-tomorrow-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium">Usar para Mañana</button>
			</div>
		</div>
	</div>	    
    <!-- Modal para agregar múltiples indicaciones -->
    <div id="bulk-modal" class="fixed inset-0 z-60 hidden">
      <div class="absolute inset-0 bg-black/40"></div>
      <div class="relative mx-auto my-10 bg-white rounded-lg shadow-lg p-4 w-11/12 max-w-2xl">
        <h3 class="text-base font-semibold text-gray-900">Agregar múltiples indicaciones</h3>
        <p class="text-xs text-gray-500 mt-1">Escribe cada indicación en una nueva línea.</p>
        <textarea id="bulk-textarea" class="mt-3 w-full h-56 border border-gray-300 rounded-md p-2 focus:outline-none focus:ring focus:ring-blue-200" placeholder="Ejemplo:
Paracetamol 1g cada 8 hrs
Omeprazol 40mg al día
Furosemida 40mg al día"></textarea>
        <div class="mt-2 text-xs text-gray-600">Líneas válidas: <span id="bulk-count">0</span></div>
        <div class="mt-4 flex justify-end gap-2">
          <button id="bulk-cancel" class="px-3 py-1.5 rounded-md border border-gray-300 hover:bg-gray-50">Cancelar</button>
          <button id="bulk-add" class="px-3 py-1.5 rounded-md bg-blue-600 text-white hover:bg-blue-700">Agregar</button>
        </div>
      </div>
    </div>

	<!-- Nuevo Modal para Corregir un Registro de Administración -->
	<div id="correction-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg">
			<!-- Encabezado -->
			<div class="flex items-start gap-4 mb-4">
				<div class="flex-shrink-0 mt-1">
					<svg class="h-6 w-6 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>
				</div>
				<div>
					<h3 id="correction-modal-title" class="text-lg font-bold text-gray-900">Corregir Registro de Administración</h3>
					<p id="correction-modal-subtitle" class="text-sm text-gray-500 mt-1"></p>
				</div>
			</div>

			<!-- Contenido del Modal -->
			<div class="space-y-4">
				<!-- Sección del Registro Original (No editable) -->
				<div>
					<label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Registro Original</label>
					<div id="correction-original-details" class="mt-1 text-sm p-3 bg-gray-50 rounded-md border border-gray-200">
						<!-- Los detalles del registro original se insertarán aquí -->
					</div>
				</div>

				<!-- Sección del Nuevo Registro (Editable) -->
				<div id="correction-mode-section">
					<label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Nuevo Registro</label>
					<div class="mt-1 p-3 border border-gray-200 rounded-md space-y-3">
						<!-- Inputs de Fecha y Hora -->
						<div class="grid grid-cols-2 gap-4">
							<div>
								<label for="correction-date-input" class="block text-sm font-medium text-gray-700 mb-1">Fecha</label>
								<input type="date" id="correction-date-input" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm">
							</div>
							<div>
								<label for="correction-time-input" class="block text-sm font-medium text-gray-700 mb-1">Hora</label>
								<input type="time" id="correction-time-input" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm">
							</div>
						</div>
						<!-- Botones de Estado -->
		                <div id="correction-status-buttons" class="grid grid-cols-2 gap-2">
		                    <!-- <button data-status="done" class="flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md border bg-white hover:bg-gray-50"> -->
							<button data-status="done" class="flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md border bg-white hover:bg-gray-50">
		                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
		                        Administrado
		                    </button>
							<!-- <button data-status="not-done" class="flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md border bg-white hover:bg-gray-50"> -->
		                    <button data-status="not-done" class="flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md border bg-white hover:bg-gray-50">
		                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
		                        No Administrado
		                    </button>
		                </div>
						<!-- Razones de No Administración (Oculto por defecto) -->
						<div id="correction-reasons-container" class="hidden space-y-2">
							<label class="block text-sm font-medium text-gray-700">Razón de No Administración:</label>
							<div class="flex flex-wrap gap-2">
								<button data-reason="Paciente en examen" class="reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">En examen</button>
								<button data-reason="Paciente se niega" class="reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Se niega</button>
								<button data-reason="No hay stock" class="reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Sin stock</button>
								<button data-reason="Indicación suspendida" class="reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Suspendida</button>
							</div>
						</div>
						<!-- Observaciones -->
						<div>
							<label for="correction-obs-textarea" class="block text-sm font-medium text-gray-700 mb-1">Observaciones</label>
							<textarea id="correction-obs-textarea" rows="2" class="w-full border border-gray-300 rounded-md px-2 py-1 text-sm" placeholder="Observaciones adicionales..."></textarea>
						</div>
					</div>
				</div>

				<!-- Razón de la Corrección (Obligatorio) -->
				<div>
					<label id="correction-reason-label" class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Motivo de la Corrección (Obligatorio)</label>
					<div id="correction-reason-buttons" class="mt-1 flex flex-wrap gap-2">
						<button data-correction-reason="Error de registro" class="correction-reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Error registro</button>
						<button data-correction-reason="Indicación médica posterior" class="correction-reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Indicación médica</button>
						<button data-correction-reason="Ajuste de horario" class="correction-reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Ajuste horario</button>
						<button data-correction-reason="Otro" class="correction-reason-button text-sm px-3 py-1.5 rounded-md bg-gray-100 hover:bg-gray-200">Otro</button>
					</div>
				</div>
			</div>

			<!-- Botones de Acción del Modal -->
			<div class="mt-6 flex justify-between items-center">
				<!-- Contenedor para los botones de la izquierda (Borrar / Volver) -->
				<div id="correction-modal-left-actions">
					<button id="correction-modal-delete-btn" class="px-4 py-2 text-sm text-red-600 hover:text-red-800 font-medium">Borrar Registro</button>
					<button id="correction-modal-back-btn" class="px-4 py-2 text-sm text-blue-600 hover:text-blue-800 font-medium hidden">Volver a Corregir</button>
				</div>
				<div class="flex gap-3">
					<button id="correction-modal-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cancelar</button>
					<button id="correction-modal-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium">Guardar Corrección</button>
				</div>
			</div>
		</div>
	</div>
	
	<!-- Nuevo Modal de Confirmación Genérico (3 Opciones) -->
	<div id="confirm-action-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden" style="z-index: 100;">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
			<!-- Encabezado -->
			<div class="flex items-start gap-4">
				<div class="flex-shrink-0 mt-1">
					<svg class="h-6 w-6 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126z" /></svg>
				</div>
				<div>
					<h3 id="confirm-action-title" class="text-lg font-bold text-gray-900"></h3>
					<p id="confirm-action-message" class="text-sm text-gray-500 mt-1"></p>
				</div>
			</div>

			<!-- Botones de Acción del Modal -->
			<div class="mt-6 flex justify-end gap-3">
				<button id="confirm-action-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium"></button>
				<button id="confirm-action-discard-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium"></button>
				<button id="confirm-action-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"></button>
			</div>
		</div>
	</div>

	<!-- Nuevo Modal para Editar un Horario Individual -->
	<div id="edit-schedule-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
			<!-- Encabezado -->
			<div class="flex items-start gap-4 mb-4">
				<div class="flex-shrink-0 mt-1">
					<svg class="h-6 w-6 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0h18M-4.5 12h22.5" /></svg>
				</div>
				<div>
					<h3 id="edit-schedule-title" class="text-lg font-bold text-gray-900">Editar Horario Programado</h3>
					<p id="edit-schedule-subtitle" class="text-sm text-gray-500 mt-1"></p>
				</div>
			</div>

			<!-- Contenido del Modal -->
			<div class="space-y-4">
				<div class="grid grid-cols-2 gap-4">
					<div>
						<label for="edit-schedule-date-input" class="block text-sm font-medium text-gray-700 mb-1">Nueva Fecha</label>
						<input type="date" id="edit-schedule-date-input" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm">
					</div>
					<div>
						<label for="edit-schedule-time-input" class="block text-sm font-medium text-gray-700 mb-1">Nueva Hora</label>
						<input type="time" id="edit-schedule-time-input" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm">
					</div>
				</div>
			</div>

			<!-- Botones de Acción del Modal -->
			<div class="mt-6 flex justify-between items-center">
				<button id="edit-schedule-delete-btn" class="px-4 py-2 text-sm text-red-600 hover:text-red-800 font-medium">Eliminar Horario</button>
				<div class="flex gap-3">
					<button id="edit-schedule-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cancelar</button>
					<button id="edit-schedule-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium">Guardar Cambio</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Nuevo Modal para Opciones de Nueva Hoja -->
	<div id="new-sheet-options-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden" style="z-index: 90;">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
			<h3 class="text-lg font-bold text-gray-900">Crear Nueva Hoja de Indicaciones</h3>
			<p class="text-sm text-gray-600 mt-2">Estás a punto de crear una nueva hoja para el día <strong id="new-sheet-date-display"></strong>. Las indicaciones actuales serán archivadas.</p>
			<p class="text-sm text-gray-600 mt-2">¿Cómo te gustaría proceder?</p>
			
			<div class="mt-4 space-y-3">
				<button id="new-sheet-repeat-btn" class="w-full flex items-center text-left p-3 border rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500">
					<svg class="h-6 w-6 text-blue-600 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375v-4.5a7.5 7.5 0 00-7.5-7.5h-1.5m7.5 10.375h.008v.015h-.008v-.015zm0 0h.008v.015h-.008v-.015z" /></svg>
					<div>
						<p class="font-semibold">Repetir Indicaciones Activas</p>
						<p class="text-xs text-gray-500">Copia todas las indicaciones generales y farmacológicas activas a la nueva hoja.</p>
					</div>
				</button>
				<button id="new-sheet-blank-btn" class="w-full flex items-center text-left p-3 border rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500">
					<svg class="h-6 w-6 text-blue-600 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" /></svg>
					<div>
						<p class="font-semibold">Empezar Hoja en Blanco</p>
						<p class="text-xs text-gray-500">Crea una nueva hoja con todas las indicaciones vacías.</p>
					</div>
				</button>
			</div>
			<div class="mt-6 flex justify-end">
				<button id="new-sheet-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cancelar</button>
			</div>
		</div>
	</div>

	<!-- Nuevo Modal para Ver y Corregir Historial SOS -->
	<div id="sos-history-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl">
			<!-- Encabezado -->
			<div class="flex items-start gap-4 mb-4">
				<div class="flex-shrink-0 mt-1">
					<svg class="h-6 w-6 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
				</div>
				<div>
					<h3 id="sos-history-title" class="text-lg font-bold text-gray-900">Historial de Administración SOS</h3>
					<p id="sos-history-subtitle" class="text-sm text-gray-500 mt-1"></p>
				</div>
			</div>

			<!-- Contenido del Modal (Tabla de Historial) -->
			<div class="max-h-[60vh] overflow-y-auto">
				<table class="w-full text-sm text-left">
					<thead class="bg-gray-50 sticky top-0">
						<tr>
							<th class="p-2 font-medium">Fecha / Hora</th>
							<th class="p-2 font-medium">Estado</th>
							<th class="p-2 font-medium">Razón / Obs.</th>
							<th class="p-2 font-medium">Acción</th>
						</tr>
					</thead>
					<tbody id="sos-history-table-body" class="divide-y divide-gray-200">
						<!-- Las filas del historial se insertarán aquí -->
					</tbody>
				</table>
			</div>

			<!-- Botones de Acción del Modal -->
			<div class="mt-6 flex justify-end">
				<button id="sos-history-close-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cerrar</button>
			</div>
		</div>
	</div>

    <!-- Tooltip para las observaciones (nuevo) -->
    <div id="tooltip" role="tooltip">
		<div id="tooltip-content"></div> <!-- Contenedor dedicado para el texto -->
		<div id="tooltip-arrow" class="arrow-container">
			<svg viewBox="0 0 16 8" class="arrow-svg">
				<path d="M0 8L8 0L16 8" class="arrow-stroke"></path>
				<path d="M1.5 8L8 1.5L14.5 8" class="arrow-fill"></path>
			</svg>
		</div>
	</div>
	
	<!-- Pop-over para la Administración de Horarios -->
	<div id="schedule-popover" class="schedule-popover">
		<!-- Flecha SVG para el Pop-over -->
		<div id="popover-arrow" class="arrow-container">
			<svg viewBox="0 0 16 8" class="arrow-svg">
				<!-- Path para el BORDE (se dibuja detrás) -->
				<path d="M0 8L8 0L16 8" class="arrow-stroke"></path>
				<!-- Path para el RELLENO (se dibuja encima y enmascara la base del borde) -->
				<path d="M1.5 8L8 1.5L14.5 8" class="arrow-fill"></path>
			</svg>
		</div>
		<!-- Paso 1: Acciones principales -->
		<div id="modal-step-1">
			<p class="text-sm font-semibold mb-3 text-gray-800" id="modal-schedule-text-step-1"></p>
			<div class="grid grid-cols-2 gap-2 mb-3">
				<div>
					<label class="block text-xs font-medium text-gray-700 mb-1">Fecha</label>
					<input type="date" id="admin-date-input" class="w-full border border-gray-300 rounded-md px-2 py-1 text-xs">
				</div>
				<div>
					<label class="block text-xs font-medium text-gray-700 mb-1">Hora</label>
					<input type="time" id="admin-time-input" class="w-full border border-gray-300 rounded-md px-2 py-1 text-xs">
				</div>
			</div>
			<div class="flex flex-col gap-2">
				<button id="admin-done-btn" class="admin-done px-3 py-2 bg-green-600 text-white rounded-md text-sm font-medium hover:bg-green-700 flex items-center justify-center gap-2">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
					Administrado
				</button>
				<button id="admin-not-done-btn" class="admin-not-done px-3 py-2 bg-red-600 text-white rounded-md text-sm font-medium hover:bg-red-700 flex items-center justify-center gap-2">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
					No Administrado
				</button>
			</div>
		</div>
	</div>

	<!-- Nuevo Modal para Indicar Razón de No Administración -->
	<div id="reason-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 hidden">
		<div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
			<div class="flex items-start gap-4">
				<!-- Ícono -->
				<div id="reason-modal-icon" class="flex-shrink-0 mt-1">
					<!-- Ícono se insertará aquí -->
				</div>
				<!-- Contenido -->
				<div>
					<h3 id="reason-modal-title" class="text-lg font-bold text-gray-900"></h3>
					<div id="reason-modal-content" class="mt-4 space-y-3">
						<!-- Los botones de razón y el textarea se moverán aquí desde el pop-over -->
						<div class="space-y-1">
							<button class="reason-btn w-full px-3 py-2 text-sm text-left rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700" data-reason="Paciente en examen">Paciente en examen</button>
							<button class="reason-btn w-full px-3 py-2 text-sm text-left rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700" data-reason="Paciente se niega">Paciente se niega</button>
							<button class="reason-btn w-full px-3 py-2 text-sm text-left rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700" data-reason="No hay stock">No hay stock</button>
							<button class="reason-btn w-full px-3 py-2 text-sm text-left rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700" data-reason="Indicación suspendida">Indicación suspendida</button>
							<button class="reason-btn w-full px-3 py-2 text-sm text-left rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700" data-reason="Otro...">Otro...</button>
						</div>
						<div>
							<label class="block text-sm font-medium text-gray-700 mb-1">Razón / Observaciones</label>
							<textarea id="reason-modal-textarea" class="w-full border border-gray-300 rounded-md px-2 py-1 text-sm" rows="3" placeholder="Detalles adicionales..."></textarea>
						</div>
					</div>
				</div>
			</div>
			<!-- Botones de Acción -->
			<div class="mt-6 flex justify-end gap-3">
				<button id="reason-modal-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-medium">Cancelar</button>
				<button id="reason-modal-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium">Guardar Registro</button>
			</div>
		</div>
	</div>
	
	
    <!-- Contenedor de toasts -->
    <div id="toast-container" class="fixed bottom-4 right-4 z-60 space-y-2 pointer-events-none"></div>

    <script>
		'use strict';

		// =================================================================================
		// MÓDULO DE CONFIGURACIÓN
		// =================================================================================
		const Config = {
			DB_NAME: 'MedicalIndicationsDB',
		    DB_VERSION: 2,
		    SHEET_STORE: 'sheets', // Nuevo nombre para la tabla de hojas
		    META_STORE: 'app_meta', // Nueva tabla para metadatos
			ADMINISTRATION_ROUTES: ['VO', 'EV', 'SC', 'Otro'],
			ROLES: { medico: 'Médico', enfermera: 'Enfermera', tens: 'TENS' },
			INDICATION_STATUS: { ACTIVE: 'active', SUSPENDED: 'suspended', DRAFT: 'draft', PENDING_SCHEDULE: 'pending-schedule', CANCELLED: 'cancelled'},
			LOG_ACTIONS: {
				UPDATE_SCHEDULES: 'UPDATE_SCHEDULES',
				EDIT_SINGLE_SCHEDULE: 'EDIT_SINGLE_SCHEDULE',
				AUTHORIZE_DRAFT: 'AUTHORIZE_DRAFT',
				ADMINISTER_MED: 'ADMINISTER_MED',
			    ADMINISTER_SOS_MED: 'ADMINISTER_SOS_MED',
			    CORRECT_ADMINISTRATION: 'CORRECT_ADMINISTRATION',
			    DELETE_ADMINISTRATION: 'DELETE_ADMINISTRATION'
			}
		};

		// =================================================================================
		// MÓDULO DE UTILIDADES
		// =================================================================================
		const Utils = {
			getRouteColor: (route) => {
				const colors = { 'VO': 'bg-blue-100 text-blue-800', 'EV': 'bg-green-100 text-green-800', 'SC': 'bg-yellow-100 text-yellow-800', 'Otro': 'bg-gray-100 text-gray-800' };
				return colors[route] || 'bg-gray-100 text-gray-800';
			},
			formatDate: (dateString) => {
		        // ¡CORRECCIÓN CLAVE! Para evitar problemas de zona horaria,
		        // reemplazamos los guiones por barras. El constructor de Date
		        // trata 'YYYY/MM/DD' como local, pero 'YYYY-MM-DD' como UTC.
		        const localDateString = dateString.replace(/-/g, '/');
		        const date = new Date(localDateString);
				return date.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
			},
			autoResizeTextarea: (textarea) => {
				if (!textarea) return;
				textarea.style.height = 'auto';
				textarea.style.height = `${textarea.scrollHeight}px`;
			},
			validateDateTime: (date, time) => new Date(`${date}T${time}`) <= new Date(),
			toLocalISOString: function(date) {
				const pad = (num) => String(num).padStart(2, '0');
				
				const year = date.getFullYear();
				const month = pad(date.getMonth() + 1); // Meses son 0-indexados
				const day = pad(date.getDate());
				const hours = pad(date.getHours());
				const minutes = pad(date.getMinutes());
				const seconds = pad(date.getSeconds());
				
				// Construimos el string en el formato YYYY-MM-DDTHH:mm:ss.sssZ
				// La 'Z' es importante para que siga siendo un formato válido,
				// pero los componentes son de la hora local.
				return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.000Z`;
			},
			parseISOLocal: function(isoString) {
				if (!isoString || typeof isoString !== 'string') return null;
				// Dividimos el string en sus componentes de fecha y hora
				const parts = isoString.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/);
				if (!parts) return new Date(isoString); // Si no coincide, volvemos al comportamiento por defecto

				// Creamos una nueva fecha usando los componentes numéricos.
				// Esto fuerza al constructor de Date a usar la zona horaria local.
				// Restamos 1 al mes porque en JS los meses son 0-indexados (Enero=0).
				return new Date(parts[1], parts[2] - 1, parts[3], parts[4], parts[5], parts[6]);
			},
			formatScheduleTime: (dateTimeString) => {
				// Caso especial para SOS
				if (!dateTimeString || dateTimeString === 'SOS') {
					return 'SOS';
				}

				try {
					const date = Utils.parseISOLocal(dateTimeString);
					// Verificamos si la fecha es válida, por si acaso
					if (isNaN(date.getTime())) {
						return dateTimeString; // Devolvemos el original si no es una fecha válida
					}

					const hours = date.getHours();
					const minutes = date.getMinutes();

					// Lógica para el formato HH o HH:MM
					if (minutes === 0) {
						// Si son las 00:00, mostramos "0" o "00" según prefieras. "String(hours)" es más natural.
						return String(hours); 
					} else {
						return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
					}
				} catch (error) {
					// Si algo falla, devolvemos el string original para no romper la UI
					return dateTimeString;
				}
			},
		    getEffectiveAdminData: (adminObject) => {
		        if (!adminObject) return null;
		        // Si el registro ha sido corregido y tiene correcciones,
		        // devolvemos el objeto 'newState' de la última corrección.
		        if (adminObject.isCorrected && adminObject.corrections && adminObject.corrections.length > 0) {
		            return adminObject.corrections[adminObject.corrections.length - 1].newState;
		        }
		        // Si no, devolvemos el objeto de administración original.
		        return adminObject;
		    },
				// Función para mover cursor al final de un textarea/input
		    moveCursorToEnd: (element) => {
		        if (element && typeof element.selectionStart == "number") {
		            element.selectionStart = element.selectionEnd = element.value.length;
		        }
		    },
		    // --- NUEVA FUNCIÓN DE AYUDA ---
		    /**
		     * Compara dos objetos y devuelve true si son diferentes.
		     * Opcionalmente, puede comparar solo un subconjunto de claves.
		     * @param {object} objA El primer objeto.
		     * @param {object} objB El segundo objeto.
		     * @param {string[]} [keysToCompare=null] Un array opcional de claves a comparar. Si es null, compara todas.
		     * @returns {boolean} True si hay diferencias, false si son iguales.
		     */
		    areObjectsDifferent: (objA, objB, keysToCompare = null) => {
		        const keys = keysToCompare || Object.keys({ ...objA, ...objB });
		
		        for (const key of keys) {
		            if (objA[key] !== objB[key]) {
		                return true; // Encontró una diferencia, termina temprano.
		            }
		        }
		
		        return false; // No encontró diferencias.
		    },
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA PROCESAR HORARIOS ---
		    /**
		     * Convierte un string de horarios (ej. "19-01-07") en un array de objetos de horario,
		     * infiriendo secuencialmente si cada horario corresponde a hoy o mañana.
		     * @param {string} schedulesString El string de horarios a procesar.
		     * @param {string} baseDateString La fecha base (DD-MM-YYYY) para "hoy".
		     * @returns {object[]} Un array de objetos de horario temporales.
		     */
		    processSchedulesString: (schedulesString, baseDateString) => {
		        const parts = schedulesString.split('-').map(s => s.trim().toUpperCase()).filter(Boolean);
		        if (parts.length === 0) return [];
		
		        const now = new Date();
		        let currentDay = new Date(baseDateString);
		        let previousHour = -1; // Empezamos con una hora imposible
		
		        const processedSchedules = parts.map(time => {
		            if (time === 'SOS') {
		                return { id: 'SOS', dateTime: 'SOS', status: 'active' };
		            }
		
		            const [hours, minutes] = time.split(':').map(Number);
		            if (isNaN(hours) || (minutes && isNaN(minutes))) return null;
		
		            // Lógica de inferencia secuencial
		            // Si la hora actual es menor que la anterior, avanzamos al día siguiente.
		            if (hours < previousHour) {
		                currentDay.setDate(currentDay.getDate() + 1);
		            }
		            // Si la hora actual es igual a la anterior, también avanzamos (no permitir duplicados en el mismo día)
		            else if (hours === previousHour && minutes <= (new Date().getMinutes())) {
		                 currentDay.setDate(currentDay.getDate() + 1);
		            }
		
		            const scheduleDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), hours, minutes || 0);
		            
		            previousHour = hours; // Actualizamos la última hora procesada
		
		            const isoString = Utils.toLocalISOString(scheduleDate);
		            return { id: isoString, dateTime: isoString, status: 'active' };
		        });
		
		        return processedSchedules.filter(Boolean); // Limpiamos cualquier 'null' de horarios inválidos
		    },		

		    // --- NUEVA FUNCIÓN DE AYUDA ---
		    /**
		     * Compara dos strings de horarios para ver si son equivalentes,
		     * ignorando espacios y el orden.
		     * @param {string} strA El primer string de horarios.
		     * @param {string} strB El segundo string de horarios.
		     * @returns {boolean} True si son equivalentes, false si no.
		     */
		    areScheduleStringsEquivalent: (strA, strB) => {
		        // Normalizamos los strings: quitamos espacios, convertimos a mayúsculas,
		        // dividimos en partes y ordenamos el array resultante.
		        const normalize = (str) => (str || '')
		            .split('-')
		            .map(s => s.trim().toUpperCase())
		            .filter(Boolean)
		            .sort()
		            .join('-');
		
		        return normalize(strA) === normalize(strB);
		    },			
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA EL HISTORIAL DE CORRECCIONES ---
		    /**
		     * Formatea el historial de correcciones de un registro para un tooltip.
		     * @param {object} originalAdminData El objeto de registro original.
		     * @returns {string} Un string HTML formateado para el tooltip.
		     */
		    formatCorrectionHistoryTooltip: (originalAdminData) => {
		        if (!originalAdminData || !originalAdminData.isCorrected || !originalAdminData.corrections) {
		            return '';
		        }
				
				let historyHtml = '';
				const allStates = [originalAdminData, ...originalAdminData.corrections];
		
		        // El estado vigente es el último en el array de correcciones
		        const latestCorrection = originalAdminData.corrections[originalAdminData.corrections.length - 1];
		        const effectiveState = latestCorrection.newState;
		        const effectiveStatusText = effectiveState.status === 'done' ? 'Administrado' : 'No Administrado';
		        const [effYear, effMonth, effDay] = effectiveState.adminDate.split('-');
		        const effFormattedDate = `${effDay}/${effMonth}/${effYear.slice(-2)}`;
		
		        // 1. Añadimos el estado vigente (sin cursiva)
		        historyHtml += `<b>Vigente (${effFormattedDate} ${effectiveState.adminTime})</b><br>`;
		        historyHtml += `&bull; Estado: ${effectiveStatusText}<br>`;
		        if (effectiveState.reason) {
		            historyHtml += `&bull; Razón: ${effectiveState.reason}<br>`;
		        }
		        historyHtml += `&bull; Motivo Corrección: ${latestCorrection.reasonForCorrection}<br><br>`;
		
		        // 2. Añadimos el resto de las correcciones y el original (en cursiva)
		        // Iteramos en orden inverso, saltándonos la última corrección que ya mostramos
		        for (let i = originalAdminData.corrections.length - 2; i >= 0; i--) {
		            const correction = originalAdminData.corrections[i];
		            const state = correction.newState;
		            const statusText = state.status === 'done' ? 'Administrado' : 'No Administrado';
		            const [year, month, day] = state.adminDate.split('-');
		            const formattedDate = `${day}/${month}/${year.slice(-2)}`;
		
		            historyHtml += `<span class="text-gray-400"><i><b>Corrección #${i + 1} (${formattedDate} ${state.adminTime})</b><br>`;
		            historyHtml += `&bull; Estado: ${statusText}<br>`;
		           if (state.reason) {
		                historyHtml += `&bull; Razón: ${state.reason}<br>`;
		            }
		            historyHtml += `&bull; Motivo Corrección: ${correction.reasonForCorrection}</i></span><br><br>`;
		        }
		
		        // 3. Añadimos el estado original al final (en cursiva)
		        const originalStatusText = originalAdminData.status === 'done' ? 'Administrado' : 'No Administrado';
		        const [oYear, oMonth, oDay] = originalAdminData.adminDate.split('-');
		        const oFormattedDate = `${oDay}/${oMonth}/${oYear.slice(-2)}`;
		        historyHtml += `<span class="text-gray-400"><i><b>Original (${oFormattedDate} ${originalAdminData.adminTime})</b><br>`;
		        historyHtml += `&bull; Estado: ${originalStatusText}</i></span>`;
								
		        return historyHtml;
		    },	

		    // --- NUEVA FUNCIÓN DE AYUDA PARA ESCAPAR HTML ---
		    /**
		     * Escapa caracteres HTML para un uso seguro en atributos.
		     * @param {string} str El string a escapar.
		     * @returns {string} El string escapado.
		     */
		    escapeHTML: (str) => {
		        if (!str) return '';
		        return str.replace(/[&<>"']/g, function(match) {
		            return {
		                '&': '&amp;',
		                '<': '&lt;',
		                '>': '&gt;',
		                '"': '&quot;',
		                "'": '&#39;'
		            }[match];
		        });
		    },		
			
			// Función para clonar objetos profundamente, crucial para el backup
			deepClone: (obj) => JSON.parse(JSON.stringify(obj))
		};

		// =================================================================================
		// MÓDULO DE ESTADO DE LA APLICACIÓN
		// =================================================================================
		const AppState = {
			db: null,
			currentSheet: null, // Almacenará el snapshot del día que estamos viendo
			activeSheetDate: null, // La fecha de la última hoja editable

			initDB: function() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(Config.DB_NAME, Config.DB_VERSION);
					request.onerror = () => reject('IndexedDB error');
					
					request.onupgradeneeded = e => {
						const db = e.target.result;
						// Eliminamos la tabla antigua si existe
						if (db.objectStoreNames.contains('indications')) {
							db.deleteObjectStore('indications');
						}
						// Creamos las nuevas tablas
						if (!db.objectStoreNames.contains(Config.SHEET_STORE)) {
							db.createObjectStore(Config.SHEET_STORE, { keyPath: 'date' });
						}
						if (!db.objectStoreNames.contains(Config.META_STORE)) {
							db.createObjectStore(Config.META_STORE, { keyPath: 'id' });
						}
					};

					request.onsuccess = e => {
						this.db = e.target.result;
						resolve(this.db);
					};
				});
			},

			// Carga los metadatos (la fecha activa)
			loadMeta: function() {
				return new Promise((resolve) => {
					const transaction = this.db.transaction(Config.META_STORE, 'readonly');
					const store = transaction.objectStore(Config.META_STORE);
					const request = store.get('metadata');
					request.onsuccess = e => {
						if (e.target.result) {
							this.activeSheetDate = e.target.result.activeSheetDate;
						} else {
							// Si no hay metadatos, el día activo es hoy
							this.activeSheetDate = new Date().toISOString().split('T')[0];
						}
						resolve();
					};
					request.onerror = () => {
						this.activeSheetDate = new Date().toISOString().split('T')[0];
						resolve(); // Resolvemos igualmente para que la app no se rompa
					};
				});
			},

			// Guarda los metadatos
			saveMeta: function() {
				return new Promise((resolve, reject) => {
					const transaction = this.db.transaction(Config.META_STORE, 'readwrite');
					const store = transaction.objectStore(Config.META_STORE);
					store.put({ id: 'metadata', activeSheetDate: this.activeSheetDate });
					transaction.oncomplete = () => resolve();
					transaction.onerror = e => reject(e.target.error);
				});
			},

			// Carga una hoja específica por fecha
			loadSheet: function(dateString) {
				return new Promise((resolve) => {
					const transaction = this.db.transaction(Config.SHEET_STORE, 'readonly');
					const store = transaction.objectStore(Config.SHEET_STORE);
					const request = store.get(dateString);
					request.onsuccess = e => {
						this.currentSheet = e.target.result;
						resolve(this.currentSheet);
					};
					request.onerror = () => resolve(null);
				});
			},

			// Guarda la hoja actual
			saveCurrentSheet: function() {
				if (!this.currentSheet) return Promise.reject('No current sheet to save');
				return new Promise((resolve, reject) => {
					const transaction = this.db.transaction(Config.SHEET_STORE, 'readwrite');
					const store = transaction.objectStore(Config.SHEET_STORE);
					store.put(this.currentSheet);
					transaction.oncomplete = () => resolve();
					transaction.onerror = e => reject(e.target.error);
				});
			},

			// Función de ayuda para actualizar datos dentro de la hoja actual
			updateCurrentSheetData: function(updates) {
				if (!this.currentSheet) return;
				Object.assign(this.currentSheet.data, updates);
				this.saveCurrentSheet();
				UI.render();
			},
			
			updateIndicationStatus: function(indicationId, scheduleId, data) {
				const indication = this.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
				if (indication) {
					// Caso 1: Es una administración SOS
					if (scheduleId === 'SOS') {
						if (!indication.sosHistory) {
							indication.sosHistory = [];
						}
						// Creamos una nueva entrada en el historial
						const newHistoryEntry = {
							id: new Date().getTime(), // Usaremos el timestamp como un ID numérico
							originalScheduleId: scheduleId, // Guardamos que es un SOS
							...data // Copiamos todos los datos (status, reason, adminTime, etc.)
						};
						indication.sosHistory.push(newHistoryEntry);
					} 
					// Caso 2: Es un horario normal
					else {
						if (!indication.administered) {
							indication.administered = {};
						}
						indication.administered[scheduleId] = data;
					}
					
					this.saveCurrentSheet();
					UI.render();
				}
			},
			
		};

		// =================================================================================
		// MÓDULO DE ESTADO DE LA UI
		// =================================================================================
		const UIState = {
			currentRole: 'medico',
			viewingDate: null, // La fecha que el usuario está viendo
			isHistoryView: false, // True si estamos viendo una hoja archivada
			isFutureEmptyView: false, // True si estamos viendo un día futuro sin hoja
			isLateEntryMode: false, // True si la enfermera habilitó el registro tardío
			
			editingLock: { isLocked: false, lockedBy: null },
			nurseEditingMode: false,
			doctorHasDraft: false,
			
			doctorScheduleBackup: null, // Copia de seguridad para el médico
			doctorEditingData: null, // Datos que el médico está modificando
			
			nurseScheduleBackup: null,
			nurseEditingData: null,
			
			selectedSchedule: null,
			indicationToSuspend: null,
			unlockedScheduleId: null,
			correctionContext: null,
			pendingAction: null,
			newSheetDate: null
		};

		// =================================================================================
		// MÓDULO DE UI
		// =================================================================================
		const UI = {
			// Referencias a elementos del DOM
			roleSelect: null, actionButton: null, draftBanner: null, generalForm: null,
			pharmaTableHead: null, pharmacologicalIndicationsTable: null, currentDateDisplay: null,
			infoModal: null, infoModalTitle: null, infoModalMessage: null, infoModalIcon: null, infoModalCloseBtn: null,
			reasonModal: null, reasonModalTitle: null, reasonModalIcon: null, reasonModalTextarea: null, reasonModalCancelBtn: null, reasonModalSaveBtn: null,
			scheduleModal: null, modalStep1: null, modalScheduleTextStep1: null, adminDateInput: null, adminTimeInput: null,
			tooltip: null, tooltipContent: null, ghostTextarea: null,
			
			// Variables de estado de la UI
			sortableInstance: null, cleanupPopover: null, cleanupTooltip: null, scheduleModalButton: null,

			init: function() {
				// Asignación manual y explícita de cada elemento del DOM para máxima robustez.
				this.roleSelect = document.getElementById('role-select');
				
				this.prevDayButton = document.getElementById('prev-day');
				this.nextDayButton = document.getElementById('next-day');
				this.actionButton = document.getElementById('action-button');
				this.draftBanner = document.getElementById('draft-banner');
				this.nurseDraftBanner = document.getElementById('nurse-draft-banner');
								
				this.generalForm = document.getElementById('general-indications-form');
				
				this.pharmaTableHead = document.getElementById('pharma-table-head');
				this.pharmacologicalIndicationsTable = document.getElementById('pharmacological-indications-table');
				this.currentDateDisplay = document.getElementById('current-date-display');
				this.ghostTextarea = document.getElementById('ghost-textarea');
				this.pharmaFooter = document.getElementById('pharma-footer');
				this.addNewIndicationButton = document.getElementById('add-new-indication');
				this.addMultipleToggle = document.getElementById('add-multiple-toggle');
				this.addMultipleMenu = document.getElementById('add-multiple-menu');
				this.openBulkModalBtn = document.getElementById('open-bulk-modal');
				
				this.pendingReviewSection = document.getElementById('pending-review-section');
				this.pendingReviewList = document.getElementById('pending-review-list');
				
				this.verbalIndicationsSection = document.getElementById('verbal-indications-section');
				this.verbalIndicationsList = document.getElementById('verbal-indications-list');
				this.processedVerbalSection = document.getElementById('processed-verbal-section');
				this.processedVerbalList = document.getElementById('processed-verbal-list');
				
				this.infoModal = document.getElementById('info-modal');
				this.infoModalTitle = document.getElementById('info-modal-title');
				this.infoModalMessage = document.getElementById('info-modal-message');
				this.infoModalIcon = document.getElementById('info-modal-icon');
				this.infoModalCloseBtn = document.getElementById('info-modal-close-btn');

				this.confirmHourModal = document.getElementById('confirm-hour-modal');
				this.confirmHourTitle = document.getElementById('confirm-hour-title');
				this.confirmHourMessage = document.getElementById('confirm-hour-message');
				this.confirmHourTodayBtn = document.getElementById('confirm-hour-today-btn');
				this.confirmHourTomorrowBtn = document.getElementById('confirm-hour-tomorrow-btn');

				this.reasonModal = document.getElementById('reason-modal');
				this.reasonModalTitle = document.getElementById('reason-modal-title');
				this.reasonModalIcon = document.getElementById('reason-modal-icon');
				this.reasonModalTextarea = document.getElementById('reason-modal-textarea');
				this.reasonModalCancelBtn = document.getElementById('reason-modal-cancel-btn');
				this.reasonModalSaveBtn = document.getElementById('reason-modal-save-btn');

				this.scheduleModal = document.getElementById('schedule-popover');
				this.modalStep1 = document.getElementById('modal-step-1');
				this.modalScheduleTextStep1 = document.getElementById('modal-schedule-text-step-1');
				this.adminDateInput = document.getElementById('admin-date-input');
				this.adminTimeInput = document.getElementById('admin-time-input');

				this.tooltip = document.getElementById('tooltip');
				this.tooltipContent = document.getElementById('tooltip-content');
						
				this.confirmSuspendModal = document.getElementById('confirm-suspend-modal');
				this.cancelSuspendButton = document.getElementById('cancel-suspend-button');
				this.confirmSuspendButton = document.getElementById('confirm-suspend-button');
				
				this.bulkModal = document.getElementById('bulk-modal');
				this.bulkTextarea = document.getElementById('bulk-textarea');
				this.bulkCount = document.getElementById('bulk-count');
				this.bulkCancel = document.getElementById('bulk-cancel');
				this.bulkAdd = document.getElementById('bulk-add');
				
				this.correctionModal = document.getElementById('correction-modal');
				this.correctionModalTitle = document.getElementById('correction-modal-title');
				this.correctionModalSubtitle = document.getElementById('correction-modal-subtitle');
				this.correctionOriginalDetails = document.getElementById('correction-original-details');
				this.correctionDateInput = document.getElementById('correction-date-input');
				this.correctionTimeInput = document.getElementById('correction-time-input');
				this.correctionStatusButtons = document.getElementById('correction-status-buttons');
				this.correctionReasonsContainer = document.getElementById('correction-reasons-container');
				this.correctionObsTextarea = document.getElementById('correction-obs-textarea');
				this.correctionReasonButtons = document.getElementById('correction-reason-buttons');
				this.correctionModalCancelBtn = document.getElementById('correction-modal-cancel-btn');
				this.correctionModalSaveBtn = document.getElementById('correction-modal-save-btn');
				this.correctionModalDeleteBtn = document.getElementById('correction-modal-delete-btn');
				this.correctionModeSection = document.getElementById('correction-mode-section');
			    this.correctionReasonLabel = document.getElementById('correction-reason-label');
			    this.correctionModalBackBtn = document.getElementById('correction-modal-back-btn');
							
			    this.editScheduleModal = document.getElementById('edit-schedule-modal');
			    this.editScheduleTitle = document.getElementById('edit-schedule-title');
			    this.editScheduleSubtitle = document.getElementById('edit-schedule-subtitle');
			    this.editScheduleDateInput = document.getElementById('edit-schedule-date-input');
			    this.editScheduleTimeInput = document.getElementById('edit-schedule-time-input');
			    this.editScheduleDeleteBtn = document.getElementById('edit-schedule-delete-btn');
			    this.editScheduleCancelBtn = document.getElementById('edit-schedule-cancel-btn');
			    this.editScheduleSaveBtn = document.getElementById('edit-schedule-save-btn');
				
			    this.sosHistoryModal = document.getElementById('sos-history-modal');
			    this.sosHistoryTitle = document.getElementById('sos-history-title');
			    this.sosHistorySubtitle = document.getElementById('sos-history-subtitle');
			    this.sosHistoryTableBody = document.getElementById('sos-history-table-body');
			    this.sosHistoryCloseBtn = document.getElementById('sos-history-close-btn');
				
			    this.confirmActionModal = document.getElementById('confirm-action-modal');
			    this.confirmActionTitle = document.getElementById('confirm-action-title');
			    this.confirmActionMessage = document.getElementById('confirm-action-message');
			    this.confirmActionCancelBtn = document.getElementById('confirm-action-cancel-btn');
			    this.confirmActionDiscardBtn = document.getElementById('confirm-action-discard-btn');
			    this.confirmActionSaveBtn = document.getElementById('confirm-action-save-btn');

			    this.newSheetBtn = document.getElementById('new-sheet-btn');
			    this.newSheetOptionsModal = document.getElementById('new-sheet-options-modal');
			    this.newSheetDateDisplay = document.getElementById('new-sheet-date-display');
			    this.newSheetRepeatBtn = document.getElementById('new-sheet-repeat-btn');
			    this.newSheetBlankBtn = document.getElementById('new-sheet-blank-btn');
			    this.newSheetCancelBtn = document.getElementById('new-sheet-cancel-btn');
			},

			render: function() {
				this.renderGeneralIndications();
				this.renderPharmacologicalIndications();
				this.renderPendingReviewSection();
				this.renderVerbalIndications();
				this.renderProcessedVerbalIndications();
				this.updateHeaderUI();
			},

			renderGeneralIndications: function() {
			    // ¡CORRECCIÓN CLAVE! Si no hay una hoja cargada, no renderizamos nada.
			    if (!AppState.currentSheet) {
			        this.generalForm.innerHTML = '<p class="text-sm text-gray-500">No hay indicaciones generales para esta fecha.</p>';
			        return;
			    }
			
				this.generalForm.innerHTML = '';
			    const canEdit = UIState.currentRole === 'medico' && UIState.doctorHasDraft && !UIState.isHistoryView;
			    const sourceData = UIState.doctorHasDraft ? UIState.doctorEditingData : AppState.currentSheet.data;
			    const generalIndicationsData = sourceData.generalIndications;			    
				
				const labels = { manejo: 'Manejo', reposo: 'Reposo', regimen: 'Régimen', controlIngesta: 'Control de ingesta', apoyoVentilatorio: 'Apoyo ventilatorio', balanceHidrico: 'Balance hídrico', hemoglucotest: 'Hemoglucotest', rehabilitacion: 'Rehabilitación', alergias: 'Alergias', aislamiento: 'Aislamiento', cateteres: 'Catéteres', cup: 'CUP' };

				for (const key in generalIndicationsData) {
					const value = generalIndicationsData[key];
					const label = labels[key] || key;
					const div = document.createElement('div');
					div.className = 'space-y-1';
					if (key === 'rehabilitacion') {
						div.innerHTML = `<label class="block text-sm font-medium text-gray-700">${label}</label><div class="flex flex-wrap gap-2">${Object.entries(value).map(([subKey, checked]) => `<label class="flex items-center"><input type="checkbox" data-key="${key}" data-subkey="${subKey}" ${checked ? 'checked' : ''} ${!canEdit ? 'disabled' : ''} class="mr-1" /><span class="text-sm text-gray-600 uppercase">${subKey}</span></label>`).join('')}</div>`;
					} else {
						const textarea = document.createElement('textarea');
						textarea.className = 'indication-textarea w-full border-0 focus:ring-0 focus:border-0 bg-transparent text-sm font-medium py-1 resize-none overflow-hidden disabled:bg-gray-50 disabled:text-gray-500';
						textarea.rows = 1;
						textarea.dataset.key = key;
						textarea.disabled = !canEdit;
						textarea.value = value;
						div.innerHTML = `<label class="block text-sm font-medium text-gray-700">${label}</label>`;
						div.appendChild(textarea);
						this.generalForm.appendChild(div);
						Utils.autoResizeTextarea(textarea);
					}
					this.generalForm.appendChild(div);
				}
			},

			renderPharmacologicalIndications: function() {
			    // ¡CORRECCIÓN CLAVE! Si no hay una hoja cargada, limpiamos la tabla y terminamos.
			    if (!AppState.currentSheet) {
			        this.pharmaTableHead.innerHTML = '';
			        this.pharmacologicalIndicationsTable.innerHTML = '<tr><td colspan="3" class="p-4 text-center text-sm text-gray-500">No hay indicaciones farmacológicas para esta fecha.</td></tr>';
			        return;
			    }
			
				<!----- 1. DETERMINAR CONTEXTO Y FUENTE DE DATOS ----->
				const role = UIState.currentRole;
				const isDoctorEditing = role === 'medico' && UIState.doctorHasDraft;
				const isNurseEditing = role === 'enfermera' && UIState.nurseEditingMode;

				const sourceData = isNurseEditing ? UIState.nurseEditingData : (isDoctorEditing ? UIState.doctorEditingData.pharmacologicalIndications : AppState.currentSheet.data.pharmacologicalIndications);
 
				<!----- 2. RENDERIZADO DINÁMICO DEL ENCABEZADO ----->
				let headerHTML = '<tr>';
				if (isDoctorEditing) {
					headerHTML += '<th class="px-2 py-1.5 text-left text-sm font-medium text-gray-500 uppercase w-8"></th>'; // Columna de arrastre
				}
				headerHTML += '<th class="px-2 py-1.5 text-left text-sm font-medium text-gray-500 uppercase">Indicación</th>';
				headerHTML += '<th class="px-2 py-1.5 text-left text-sm font-medium text-gray-500 uppercase w-32">Vía</th>';
				headerHTML += '<th class="px-2 py-1.5 text-left text-sm font-medium text-gray-500 uppercase w-60">Horarios</th>';
				if (isDoctorEditing) {
					headerHTML += '<th class="px-2 py-1.5 text-left text-sm font-medium text-gray-500 uppercase w-8"></th>'; // Columna de acciones
				}
				headerHTML += '</tr>';
				this.pharmaTableHead.innerHTML = headerHTML;

				<!----- 3. LÓGICA DE FILTRADO DE FILAS (RESTAURADA Y MEJORADA) --- -->
				let indicationsToRender = sourceData;
				<!-- Si NO es el médico en modo de edición, filtramos las indicaciones que son borradores. -->
				if (!isDoctorEditing) {
			        // Para la enfermera/TENS, ahora mostramos ACTIVE, SUSPENDED y PENDING_SCHEDULE.
			        // Solo ocultamos los borradores puros del médico.
			        indicationsToRender = sourceData.filter(ind => {
			            // Ocultamos los borradores puros del médico.
			            if (ind.status === Config.INDICATION_STATUS.DRAFT) {
			                return false;
			            }
			            // ¡CORRECCIÓN CLAVE! Ocultamos las indicaciones pendientes que están VERDADERAMENTE vacías
			            // (sin horarios de ningún tipo), ya que estas pertenecen a la otra sección.
			            if (ind.status === Config.INDICATION_STATUS.PENDING_SCHEDULE && (!ind.schedules || ind.schedules.length === 0)) {
			                return false;
			            }
			            // En todos los demás casos, la mostramos.
			            return true;
			        });
			    }
				<!----- 4. RENDERIZADO DEL CUERPO DE LA TABLA ----->
				this.pharmacologicalIndicationsTable.innerHTML = '';

				indicationsToRender.forEach(indication => {
					const row = document.createElement('tr');
					const isSuspended = indication.status === Config.INDICATION_STATUS.SUSPENDED;
					const isDraftOrPending = indication.status === Config.INDICATION_STATUS.DRAFT || indication.status === Config.INDICATION_STATUS.PENDING_SCHEDULE;
					row.className = `${isSuspended ? 'suspended-indication' : ''} hover:bg-gray-50 pharma-row`;
					if (isNurseEditing && indication.isDirty) {
						row.classList.add('dirty');
					}					
					row.dataset.id = indication.id;

					<!-- Celda de Arrastre (Drag Handle) - Solo para Médico en modo edición -->
					if (isDoctorEditing) {
						const dragCell = document.createElement('td');
						dragCell.className = 'px-2 py-1.5 w-8';
						if (isDraftOrPending) {
							dragCell.classList.add('drag-handle');
							dragCell.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-grip-vertical text-gray-400"><path d="M9 6v12"/><path d="M15 6v12"/></svg>`;
						}
						row.appendChild(dragCell);
					}

					<!-- Celda de Indicación (Editable para Médico en modo edición) -->
					const indicationCell = document.createElement('td');
					indicationCell.className = 'px-2 py-1.5';
					if (isDoctorEditing && isDraftOrPending) {
						const textarea = document.createElement('textarea');
						textarea.className = 'indication-textarea w-full border-0 focus:ring-0 focus:border-0 bg-transparent text-sm font-medium py-1 resize-none overflow-hidden';
						textarea.rows = 1;
						textarea.dataset.field = 'indication';
						textarea.value = indication.indication;
						indicationCell.appendChild(textarea);
					} else {
						indicationCell.innerHTML = `<span class="text-sm font-medium ${isSuspended ? 'line-through' : ''}">${indication.indication}</span>${isSuspended ? '<span class="status-badge">SUSPENDIDA</span>' : ''}`;
					}
					row.appendChild(indicationCell);

					<!--  Celda de Vía (Editable para Médico en modo edición) -->
					const routeCell = document.createElement('td');
					routeCell.className = 'px-2 py-1.5 w-32';
					if (isDoctorEditing && isDraftOrPending) {
						let routeHtml = `<div class="radio-route-group" data-field="route">`;
						routeHtml += Config.ADMINISTRATION_ROUTES.map(route => `<input type="radio" id="route-${indication.id}-${route}" name="route-${indication.id}" value="${route}" ${indication.route === route ? 'checked' : ''} /><label for="route-${indication.id}-${route}">${route}</label>`).join('');
						routeHtml += `</div>`;
						routeCell.innerHTML = routeHtml;
					} else {
						routeCell.innerHTML = `<span class="inline-flex px-2 py-0.5 text-xs font-medium rounded-full ${Utils.getRouteColor(indication.route)}">${indication.route || ''}</span>`;
					}
					row.appendChild(routeCell);

					<!-- Celda de Horarios (Lógica ya existente) -->
					const schedulesCell = document.createElement('td');
					schedulesCell.className = 'px-2 py-1.5 w-60';
					schedulesCell.innerHTML = this.buildSchedulesCellHTML(indication, isNurseEditing);
					row.appendChild(schedulesCell);			

					<!-- Celda de Acciones (Eliminar/Suspender) - Solo para Médico en modo edición -->
					if (isDoctorEditing) {
						const actionsCell = document.createElement('td');
						actionsCell.className = 'px-2 py-1.5 w-8';
						let buttonHtml = '';
						if (isDraftOrPending) {
							buttonHtml = `<button class="delete-indication text-gray-400 hover:text-red-600" data-id="${indication.id}"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg></button>`;
						} else if (indication.status === Config.INDICATION_STATUS.ACTIVE) {
							buttonHtml = `<button class="suspend-indication text-gray-400 hover:text-red-600" data-id="${indication.id}"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-ban"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg></button>`;
						}
						actionsCell.innerHTML = buttonHtml;
						row.appendChild(actionsCell);
					}

					this.pharmacologicalIndicationsTable.appendChild(row);
				});

				<!----- 5. GESTIÓN DE SORTABLE.JS ----->
				if (isDoctorEditing) {
					this.sortableInstance = Sortable.create(this.pharmacologicalIndicationsTable, {
						handle: '.drag-handle',
						ghostClass: 'sortable-ghost',
			            onUpdate: (evt) => {
			                // ¡LÓGICA CORREGIDA! Operamos sobre la copia de trabajo.
			                const sourceArray = UIState.doctorEditingData.pharmacologicalIndications;
			
			                const rows = Array.from(this.pharmacologicalIndicationsTable.children);
			                const newOrderIds = rows.map(row => parseInt(row.dataset.id));
			                
			                // Reordenamos el array en la copia de trabajo.
			                const reorderedIndications = newOrderIds.map(id => 
			                    sourceArray.find(ind => ind.id === id)
			                ).filter(Boolean); // .filter(Boolean) por seguridad
			                
			                UIState.doctorEditingData.pharmacologicalIndications = reorderedIndications;
			                // No necesitamos guardar ni re-renderizar aquí. El cambio está en la memoria
			                // y se guardará al presionar "Autorizar".
			            }
					});
				}

				<!----- 6. POST-RENDERIZADO ----->
				<!-- Ahora que todas las filas están en el DOM, encontramos y redimensionamos -->
				<!-- todos los textareas que lo necesiten. -->
				this.pharmacologicalIndicationsTable.querySelectorAll('textarea.indication-textarea').forEach(textarea => {
					Utils.autoResizeTextarea(textarea);
				});
			},
			
			buildSchedulesCellHTML: function(indication, isNurseEditing) {
				const now = new Date();
				const originalAdminData = indication.administered;
				const effectiveAdminData = Utils.getEffectiveAdminData(indication.administered);
				const isAdministered = indication.administered;

				const administeredData = indication.administered || {};
				const isSuspended = indication.status === Config.INDICATION_STATUS.SUSPENDED;
				
				// --- 1. SEPARAR LOS DATOS ---
				const oldSchedules = (indication.schedules || []).filter(s => s.status !== 'active');
				const activeNumericSchedules = (indication.schedules || []).filter(s => s.status === 'active' && s.id !== 'SOS');
				const sosSchedule = (indication.schedules || []).find(s => s.id === 'SOS' && s.status === 'active');	

				// El string para la edición masiva ahora excluye explícitamente a SOS
				let schedulesString = activeNumericSchedules.map(s => Utils.formatScheduleTime(s.dateTime)).join('-');

				if (sosSchedule) {
					schedulesString += (schedulesString ? '-' : '') + 'SOS';
				}

				// --- 2. CONSTRUIR EL HTML ---
				// --- Contenedor Principal ---
				let content = `<div class="flex items-center w-full">`;

				// --- Contenedor para los Botones (se oculta durante la edición masiva) ---
				const isMassEditingThisRow = isNurseEditing && indication.isEditingMassively;
				// Añadimos la clase 'hidden' al contenedor de botones si estamos en modo de edición masiva.
				content += `<div class="schedule-buttons-container flex flex-wrap gap-1 items-center ${isMassEditingThisRow ? 'hidden' : ''}">`;

			    // --- Bucle ÚNICO y UNIFICADO ---
			    const allSchedules = (indication.schedules || [])
					.sort((a, b) => {
						if (a.id === 'SOS') return 1;
						if (b.id === 'SOS') return -1;
						return new Date(a.dateTime) - new Date(b.dateTime);
					});
				// 2. Bucle ÚNICO y UNIFICADO
				allSchedules.forEach(schedule => {
					// --- a. Obtención de Datos ---
					let isAdministered = false;
					let effectiveAdminData = {};
					let originalAdminData = null; // Necesario para el tooltip de correcciones

					if (schedule.id === 'SOS') {
						const sosHistory = indication.sosHistory || [];
						originalAdminData = sosHistory.length > 0 ? sosHistory[sosHistory.length - 1] : null;
						isAdministered = !!originalAdminData;
						effectiveAdminData = Utils.getEffectiveAdminData(originalAdminData) || {};
					} else {
						originalAdminData = indication.administered && indication.administered[schedule.id];
						isAdministered = !!originalAdminData;
						effectiveAdminData = Utils.getEffectiveAdminData(originalAdminData) || {};
					}

					const isOrphan = schedule.status !== 'active';
					const status = effectiveAdminData.status;

					// --- b. Construcción del HTML del Botón ---
					let buttonHTML = '';
					let buttonClasses = 'schedule-button relative px-2 py-1 rounded-md text-sm font-medium';
					let statusIcon = '';
					let buttonText = Utils.formatScheduleTime(schedule.dateTime);

					if (schedule.id === 'SOS') {
						buttonText = 'SOS';
						buttonClasses += ' px-3'; // Más padding para el botón SOS
					}
					// Determinamos el estilo visual
			        if (isNurseEditing) {
			            if (isAdministered || isSuspended || schedule.id === 'SOS') buttonClasses += ' disabled-in-edit';
			            else buttonClasses += ' editable-in-edit';
			        } else {
						debugger;
			            // ¡LÓGICA REFACTORIZADA!
			            // Si es un huérfano o la indicación está suspendida, usamos el estilo de "huérfano".
			            if (isOrphan || isSuspended) {
			                let orphanClasses = 'opacity-75';
			                if (schedule.id === 'SOS') orphanClasses += ' bg-indigo-200 text-indigo-500';
			                else if (status === 'not-done') orphanClasses += ' bg-red-200 text-red-600';
			                else if (status === 'done') orphanClasses += ' bg-green-200 text-green-600';
			                else orphanClasses += ' bg-gray-200 text-gray-400';
			                buttonClasses += ` ${orphanClasses}`;
			            }
			            // Si no, usamos el estilo de "activo".
			            else {
			                if (schedule.id === 'SOS') {
			                    buttonClasses += ' bg-indigo-500 hover:bg-indigo-600 text-white';
			                } else if (status === 'done') {
			                    buttonClasses += ' bg-green-500 text-white';
			                    statusIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check absolute -top-1 -right-1 bg-green-600 text-white rounded-full p-0.5"><path d="M20 6 9 17l-5-5"/></svg>'; // SVG del check
			                } else if (status === 'not-done') {
			                    buttonClasses += ' bg-red-500 text-white';
			                    statusIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x absolute -top-1 -right-1 bg-red-600 text-white rounded-full p-0.5"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>'; // SVG de la X
			                } else {
			                    buttonClasses += ' bg-gray-200 text-gray-800 hover:bg-gray-300';
			                }
			            }
			        }
					if (originalAdminData && originalAdminData.isCorrected) {
						statusIcon += '<span class="absolute bottom-0 right-0 text-xs font-bold text-white">*</span>';
					}
					
					// --- c. Construcción del Botón ---
					const dataAttributes = `
						data-schedule-id="${schedule.id}" 
						data-indication-id="${indication.id}"
						data-observations="${effectiveAdminData.observations || ''}"
						data-reason="${effectiveAdminData.reason || ''}"
						data-admin-time="${effectiveAdminData.adminTime || ''}"
						data-admin-date="${effectiveAdminData.adminDate || ''}"
					`;

			        // ¡LÓGICA SIMPLIFICADA! Todos los botones son clickeables.
			        // La lógica de 'handleScheduleClick' decidirá qué hacer.
			        let historyAttr = '';
			        if (schedule.id === 'SOS') {
			            const history = (indication.sosHistory || []).filter(e => e.status === 'done').map(e => `${e.adminDate} ${e.adminTime}`).join(',');
			            if (history) historyAttr = `data-history="${history}"`;
			        }
			
			        buttonHTML = `
			            <button class="${buttonClasses}" ${dataAttributes} ${historyAttr}>
			                ${buttonText}${statusIcon}
			            </button>
			        `;
					
					content += buttonHTML;

					// Añadir ícono de historial SOS si es necesario
					if (schedule.id === 'SOS') {
						content += this.renderSosHistoryIcon(indication, isNurseEditing);
					}
				})

				<!-- Fin de .schedule-buttons-container -->
				content += '</div>'; // Fin de .schedule-buttons-container

				// --- LÓGICA NUEVA ---
				// Si la indicación está pendiente Y la enfermera está en modo edición,
				// mostramos el botón "+ Añadir Horarios".
				if (indication.status === Config.INDICATION_STATUS.PENDING_SCHEDULE && isNurseEditing) {
					// Si también hay huérfanos, añadimos un espacio.
					if (oldSchedules.length > 0) {
						content += '<div class="w-px h-5 bg-gray-300 mx-1"></div>';
					}
					content += `<button class="add-schedules-btn text-sm font-medium text-blue-600 hover:text-blue-800 px-2 py-1 rounded-md bg-blue-50 hover:bg-blue-100" data-indication-id="${indication.id}">+ Añadir Horarios</button>`;
				}

				// --- Input de Edición Masiva ---
				content += `<input type="text" data-id="${indication.id}" class="schedule-input w-full border border-gray-300 rounded-md px-2 py-1 text-sm ${isMassEditingThisRow ? '' : 'hidden'}" value="${schedulesString}" />`;
				
				// --- Botón para activar la edición masiva ---
			    // Ocultamos el contenedor de botones y el botón de editar si estamos en modo de edición masiva
			    const buttonsContainerClasses = isMassEditingThisRow ? 'hidden' : '';
			    const editAllButtonClasses = isMassEditingThisRow ? 'hidden' : '';
			
			    // (Aplica estas clases a los contenedores correspondientes)
			
			    if (isNurseEditing && (activeNumericSchedules.length > 0 || sosSchedule) && !isSuspended) {
					content += `<button class="edit-all-schedules-btn text-gray-400 hover:text-gray-600 ml-2" data-indication-id="${indication.id}"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-edit-3"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4Z"></path><path d="m15 5-3-3"></path></svg></button>`;
				}

				content += '</div>'; // Fin del contenedor principal
				return content;
			},
				
			renderPendingReviewSection: function() {
			    // ¡CORRECCIÓN CLAVE! Si no hay una hoja cargada, ocultamos la sección.
			    if (!AppState.currentSheet) {
			        this.pendingReviewSection.classList.add('hidden');
			        return;
			    }
				
				const isNurseEditing = UIState.nurseEditingMode;
				// Usamos la variable de estado correcta para el borrador del médico
				const isDoctorEditing = UIState.currentRole === 'medico' && UIState.doctorHasDraft;

				const sourceData = isNurseEditing ? UIState.nurseEditingData : AppState.currentSheet.data.pharmacologicalIndications;

				const pendingIndications = sourceData.filter(ind => 
					(ind.status === Config.INDICATION_STATUS.DRAFT || ind.status === Config.INDICATION_STATUS.PENDING_SCHEDULE) &&
					(!ind.schedules || ind.schedules.length === 0)
				);

				// ¡CORRECCIÓN CLAVE! La sección se muestra si hay indicaciones pendientes
				// Y si NO estamos en el modo de edición del médico.
				// Esto cubre correctamente a la Enfermera, al TENS y al Médico en solo lectura.
				if (pendingIndications.length > 0 && !isDoctorEditing) {
					this.pendingReviewSection.classList.remove('hidden');
					this.pendingReviewList.innerHTML = pendingIndications.map(indication => {
						const routeChip = `<span class="ml-2 inline-flex px-2 py-0-5 text-xs font-medium rounded-full ${Utils.getRouteColor(indication.route)}">${indication.route || ''}</span>`;
						let schedulesControl = '';

						if (isNurseEditing && UIState.currentRole === 'enfermera') {
							schedulesControl = `<input type="text" data-id="${indication.id}" class="schedule-input schedule-input-pending w-60 border border-gray-300 rounded-md px-2 py-1 text-sm" placeholder="Ej: 8-16-24" value="${indication.schedulesString || ''}" />`;
						} else {
							// Esto ahora se muestra correctamente para el Médico (solo lectura) y el TENS.
							schedulesControl = `<span class="text-sm text-gray-500 italic">Sin horarios definidos</span>`;
						}
						return `<div class="flex justify-between items-center p-1.5 bg-blue-100 rounded-md mb-1"><div><span class="text-sm font-medium">${indication.indication}</span>${routeChip}</div>${schedulesControl}</div>`;
					}).join('');
				} else {
					this.pendingReviewSection.classList.add('hidden');
				}
			},
			
			renderVerbalIndications: function() {
			    // ¡CORRECCIÓN CLAVE! Si no hay una hoja cargada, ocultamos la sección.
			    if (!AppState.currentSheet) {
			        this.verbalIndicationsSection.classList.add('hidden');
			        return;
			    }	
				
				const showVerbal = AppState.currentSheet.data.verbalIndications.length > 0;
				const isMedico = UIState.currentRole === 'medico';

				this.verbalIndicationsSection.classList.toggle('hidden', !showVerbal);
				if (showVerbal) {
					this.verbalIndicationsList.innerHTML = AppState.currentSheet.data.verbalIndications.map(indication => `
						<div class="flex justify-between items-center p-2 bg-amber-50 border border-amber-200 rounded-md">
							<div>
								<span class="text-sm font-medium">${indication.indication}</span>
								<p class="text-sm text-gray-600">
									Ingresado por ${indication.nurse} a las ${indication.time}
								</p>
							</div>
							${isMedico ? `
								<div class="flex gap-2">
									<button class="px-2 py-1 bg-green-600 text-white rounded-md text-sm hover:bg-green-700 validate-verbal" data-id="${indication.id}">
										Validar
									</button>
									<button class="px-2 py-1 bg-red-600 text-white rounded-md text-sm hover:bg-red-700 reject-verbal" data-id="${indication.id}">
										Rechazar
									</button>
								</div>
							` : ''}
						</div>
					`).join('');
				}
			},

			renderProcessedVerbalIndications: function() {
			    // ¡CORRECCIÓN CLAVE! Si no hay una hoja cargada, ocultamos la sección.
			    if (!AppState.currentSheet) {
			        this.processedVerbalSection.classList.add('hidden');
			        return;
			    }				
			
				const showProcessed = AppState.currentSheet.data.processedVerbalIndications.length > 0;
				this.processedVerbalSection.classList.toggle('hidden', !showProcessed);

				if (showProcessed) {
					this.processedVerbalList.innerHTML = AppState.currentSheet.data.processedVerbalIndications.map(indication => {
						const icon = indication.status === 'validated'
							? `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check-circle text-green-600"><path d="M22 11.08V12a10 10 0 1 1-5.93-8.03"/><path d="m9 11 3 3L22 4"/></svg>`
							: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-circle text-red-600"><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>`;

						const bgColor = indication.status === 'validated' ? 'bg-green-50' : 'bg-red-50';
						const borderColor = indication.status === 'validated' ? 'border-green-200' : 'border-red-200';

						return `
							<div class="flex items-center gap-2 p-2 ${bgColor} ${borderColor} rounded-md">
								${icon}
								<div>
									<span class="text-sm font-medium">${indication.indication}</span>
									<p class="text-sm text-gray-600">
										${indication.status === 'validated' ? 'Validado' : 'Rechazado'} por ${indication.validatedBy} a las ${indication.processedTime}
									</p>
								</div>
							</div>
						`;
					}).join('');
				}
			},

			updateHeaderUI: function() {
				this.roleSelect.value = UIState.currentRole;
				this.currentDateDisplay.textContent = Utils.formatDate(UIState.viewingDate);
				this.draftBanner.classList.toggle('hidden', !UIState.doctorHasDraft);
				this.nurseDraftBanner.classList.toggle('hidden', !UIState.nurseEditingMode);

				<!-- Añade o quita la clase de resaltado a la sección principal -->
				const pharmaSection = this.pharmacologicalIndicationsTable.closest('section');
				if (pharmaSection) {
					pharmaSection.classList.toggle('nurse-editing-mode', UIState.nurseEditingMode);
				}
				
				this.actionButton.innerHTML = ''; // Limpiamos antes de añadir
				const isMedico = UIState.currentRole === 'medico';
				const isDraft = UIState.doctorHasDraft; 
				
				<!-- Lógica botones médico -->
		        // ¡LÓGICA CORREGIDA! El botón de acción del médico solo aparece si hay una hoja.
				const isViewingActiveSheet = UIState.viewingDate === AppState.activeSheetDate;
				if (UIState.currentRole === 'medico' && AppState.currentSheet && isViewingActiveSheet) {
		            if (isDraft) {
		                this.actionButton.innerHTML = `
		                    <div class="flex items-center gap-2">
		                        <button id="authorize-draft-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-green-600 hover:bg-green-700 text-white">Autorizar</button>
		                        <button id="cancel-draft-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-gray-200 hover:bg-gray-300 text-gray-800">Cancelar</button>
		                    </div>
		                `;
		            } else {
		                this.actionButton.innerHTML = `<button id="edit-sheet-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-blue-600 hover:bg-blue-700 text-white">Editar</button>`;
		            }
					this.actionButton.classList.remove('hidden');
				<!-- Lógica de botones para la Enfermera -->
				} else if (UIState.currentRole === 'enfermera' && AppState.currentSheet && isViewingActiveSheet) {
		            if (isViewingActiveSheet) {
		                if (UIState.nurseEditingMode) {
		                    this.actionButton.innerHTML = `<div class="flex items-center gap-2"><button id="finalize-edit-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-blue-600 hover:bg-blue-700 text-white">Finalizar Edición</button><button id="cancel-edit-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-gray-200 hover:bg-gray-300 text-gray-800">Cancelar Cambios</button></div>`;
		                } else {
		                    this.actionButton.innerHTML = `<button id="edit-schedules-btn" class="px-3 py-1.5 rounded-md font-medium text-sm bg-blue-600 hover:bg-blue-700 text-white">Editar Horarios</button>`;
		                }
		                this.actionButton.classList.remove('hidden');
		            } else {
		                this.actionButton.classList.add('hidden');
		            }
				} else {
					this.actionButton.classList.add('hidden');
				}
				
			    // Mostramos el botón "Nueva Hoja" solo para el médico
			    const todayString = new Date().toISOString().split('T')[0];
			    const canCreateNewSheet = UIState.currentRole === 'medico' && 
			                              (AppState.activeSheetDate < todayString || UIState.isFutureEmptyView);
			
			    this.newSheetBtn.textContent = AppState.activeSheetDate < todayString ? 'Crear Hoja para Hoy' : 'Nueva Hoja';
			    this.newSheetBtn.classList.toggle('hidden', !canCreateNewSheet);
				
				// Lógica para el footer y sus botones
				const shouldShowFooterControls = isMedico && isDraft;
				this.pharmaFooter.classList.toggle('hidden', !shouldShowFooterControls);
				
				// ¡LÓGICA AÑADIDA!
				// También controlamos la visibilidad de los botones DENTRO del footer.
				if (this.addNewIndicationButton && this.addMultipleToggle) {
					this.addNewIndicationButton.classList.toggle('hidden', !shouldShowFooterControls);
					this.addMultipleToggle.classList.toggle('hidden', !shouldShowFooterControls);
				}
			},

			showInfoModal: function(title, message) {
				const icon = `<svg class="h-6 w-6 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126z" /></svg>`;
				this.infoModalTitle.textContent = title;
				this.infoModalMessage.textContent = message;
				this.infoModalIcon.innerHTML = icon;
				this.infoModal.classList.remove('hidden');
				this.infoModal.classList.add('visible');
				this.infoModalCloseBtn.focus();
			},
			hideInfoModal: function() {
				this.infoModal.classList.add('hidden');
				this.infoModal.classList.remove('visible');
			},

			showConfirmSuspendModal: function(indicationId) {
			    // Ahora solo guarda el ID, la lógica de estado se moverá al listener.
			    UIState.indicationToSuspend = indicationId;
			    this.confirmSuspendModal.classList.remove('hidden');
			},

			hideConfirmSuspendModal: function() {
				UIState.indicationToSuspend = null;
				this.confirmSuspendModal.classList.add('hidden');
			},

			showReasonModal: function() {
				const { indicationId, schedule } = UIState.selectedSchedule;
				const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
				this.reasonModalTitle.textContent = `Razón para no administrar ${indication.indication} (${schedule})`;
				this.reasonModalIcon.innerHTML = `<svg class="h-6 w-6 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>`;
				this.reasonModal.classList.remove('hidden');
				this.reasonModalTextarea.focus();
			},
			hideReasonModal: function() {
				this.reasonModal.classList.add('hidden');
				this.reasonModalTextarea.value = '';
				this.reasonModalTextarea.classList.remove('input-error');
				this.reasonModal.querySelectorAll('.reason-btn.selected').forEach(btn => btn.classList.remove('selected'));
			},

			showScheduleModal: function(button) {
				this.scheduleModalButton = button;
				this.modalStep1.classList.remove('hidden');
				
				<!-- this.modalScheduleTextStep1.textContent = `Marcar ${UIState.selectedSchedule.scheduleId}`; -->
				<!-- const today = new Date(); -->
				<!-- this.adminDateInput.value = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`; -->
				<!-- this.adminTimeInput.value = UIState.selectedSchedule.adminTime; -->
				
				const scheduleData = UIState.selectedSchedule;
				this.modalScheduleTextStep1.textContent = `Marcar Horario`;
				
				let dateForInput;
				let timeForInput;
				
				if (scheduleData.dateTime === 'SOS') {
			        const now = new Date();
			        dateForInput = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
			        timeForInput = now.toTimeString().slice(0, 5);
			    } else {
			        const scheduleDate = Utils.parseISOLocal(scheduleData.dateTime);
			        dateForInput = `${scheduleDate.getFullYear()}-${String(scheduleDate.getMonth() + 1).padStart(2, '0')}-${String(scheduleDate.getDate()).padStart(2, '0')}`;
			        timeForInput = `${String(scheduleDate.getHours()).padStart(2, '0')}:${String(scheduleDate.getMinutes()).padStart(2, '0')}`;
			    }
			
			    this.adminDateInput.value = dateForInput;
			    this.adminTimeInput.value = timeForInput;
				
				this.scheduleModal.classList.add('visible');
				this.cleanupPopover = FloatingUIDOM.autoUpdate(this.scheduleModalButton, this.scheduleModal, this.updatePopoverPosition.bind(this));
			},
			hideScheduleModal: function() {
				if (!this.scheduleModal.classList.contains('visible')) return;
				if (this.cleanupPopover) {
					this.cleanupPopover();
					this.cleanupPopover = null;
				}
				this.scheduleModal.classList.remove('visible');
				this.scheduleModalButton = null;
				UIState.selectedSchedule = null;
			},
			updatePopoverPosition: function() {
				if (!this.scheduleModalButton || !this.scheduleModal.classList.contains('visible')) return;
				const arrowElement = document.getElementById('popover-arrow');
				FloatingUIDOM.computePosition(this.scheduleModalButton, this.scheduleModal, {
					placement: 'top',
					middleware: [FloatingUIDOM.offset(7), FloatingUIDOM.flip(), FloatingUIDOM.shift({ padding: 5 }), FloatingUIDOM.arrow({ element: arrowElement })],
				}).then(({ x, y, placement, middlewareData }) => {
					Object.assign(this.scheduleModal.style, { left: `${x}px`, top: `${y}px` });
					this.scheduleModal.setAttribute('data-popper-placement', placement);
					const { x: arrowX, y: arrowY } = middlewareData.arrow;
					Object.assign(arrowElement.style, { left: arrowX != null ? `${arrowX}px` : '', top: arrowY != null ? `${arrowY}px` : '' });
				});
			},

			showTooltip: function(button, text) {
				this.tooltipContent.innerHTML = text;
				this.tooltip.classList.add('visible');
				const arrowElement = document.getElementById('tooltip-arrow');
				this.cleanupTooltip = FloatingUIDOM.autoUpdate(button, this.tooltip, () => {
					FloatingUIDOM.computePosition(button, this.tooltip, {
						placement: 'top',
						middleware: [FloatingUIDOM.offset(8), FloatingUIDOM.flip(), FloatingUIDOM.shift({ padding: 5 }), FloatingUIDOM.arrow({ element: arrowElement })],
					}).then(({ x, y, placement, middlewareData }) => {
						Object.assign(this.tooltip.style, { left: `${x}px`, top: `${y}px` });
						this.tooltip.setAttribute('data-popper-placement', placement);
						const { x: arrowX, y: arrowY } = middlewareData.arrow;
						Object.assign(arrowElement.style, { left: arrowX != null ? `${arrowX}px` : '', top: arrowY != null ? `${arrowY}px` : '' });
					});
				});
			},
			hideTooltip: function() {
				if (this.cleanupTooltip) {
					this.cleanupTooltip();
					this.cleanupTooltip = null;
				}
				this.tooltip.classList.remove('visible');
			},
			showCorrectionModal: function(indication, context) {
			    const isSosCorrection = typeof context !== 'string';
			    const scheduleId = isSosCorrection ? context.originalScheduleId : context;
			    const originalAdminData = isSosCorrection ? context : (indication.administered && indication.administered[scheduleId]);
			
			    if (!originalAdminData) return;
			
			    // ¡CORRECCIÓN CLAVE! Obtenemos el estado efectivo y lo usamos como la fuente de verdad.
			    const adminDataToCorrect = Utils.getEffectiveAdminData(originalAdminData);
			
			    UIState.correctionContext = { 
			        indicationId: indication.id, 
			        scheduleId: scheduleId,
			        isSos: isSosCorrection,
			        sosHistoryId: isSosCorrection ? originalAdminData.id : null
			    };
			
			    UI.correctionModalSubtitle.textContent = `${indication.indication} - Horario ${isSosCorrection ? 'SOS' : Utils.formatScheduleTime(scheduleId)}`;
			    
			    // Rellenamos la sección "Registro Actual" con los datos efectivos.
			    const effectiveStatusText = adminDataToCorrect.status === 'done' ? 'Administrado' : 'No Administrado';
			    const [year, month, day] = adminDataToCorrect.adminDate.split('-');
			    const formattedDate = `${day}/${month}/${year.slice(-2)}`;
			    UI.correctionOriginalDetails.innerHTML = `
			        <div class="flex flex-wrap -mx-2">
			            <div class="px-2 w-1/2"><span class="font-semibold">Estado:</span><span class="ml-1">${effectiveStatusText}</span></div>
			            <div class="px-2 w-1/2"><span class="font-semibold">Registrado:</span><span class="ml-1">${formattedDate} ${adminDataToCorrect.adminTime}</span></div>
			            <div class="px-2 w-full mt-2"><span class="font-semibold">Obs:</span><span class="ml-1">${adminDataToCorrect.observations || 'Ninguna'}</span></div>
			        </div>
			    `;
			
			    // Pre-llenamos los campos de edición también con los datos efectivos.
			    UI.correctionDateInput.value = adminDataToCorrect.adminDate;
			    UI.correctionTimeInput.value = adminDataToCorrect.adminTime;
			    UI.correctionObsTextarea.value = adminDataToCorrect.observations || '';
			    
				// Reseteamos los botones
			    UI.correctionStatusButtons.querySelectorAll('button').forEach(btn => {
			        btn.classList.remove('selected', 'correction-status-button');
			    });
				this.correctionReasonButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
				this.correctionReasonsContainer.classList.add('hidden');

			    // ¡LÓGICA AÑADIDA! Preseleccionamos el estado actual.
			    debugger;
				if (adminDataToCorrect.status) {
			        const statusButton = UI.correctionStatusButtons.querySelector(`[data-status="${adminDataToCorrect.status}"]`);
			        if (statusButton) {
			            statusButton.classList.add('selected', 'correction-status-button');
			            // Si el estado es 'not-done', también mostramos las razones
			            if (adminDataToCorrect.status === 'not-done') {
			                UI.correctionReasonsContainer.classList.remove('hidden');
			                // Y preseleccionamos la razón si existe
			                if (adminDataToCorrect.reason) {
			                    const reasonButton = UI.correctionReasonsContainer.querySelector(`[data-reason="${adminDataToCorrect.reason}"]`);
			                    if (reasonButton) {
			                        reasonButton.classList.add('selected');
			                    }
			                }
			            }
			        }
			    }
			    // ¡LÍNEA AÑADIDA! Aseguramos que el modal siempre se abra en modo de corrección.
			    this.setCorrectionModalMode('correct');
			
				this.correctionModal.classList.remove('hidden');
			},

			hideCorrectionModal: function() {
			    this.correctionModal.classList.add('hidden');
			    UIState.correctionContext = null;		
		
				// ¡LÓGICA DE LIMPIEZA COMPLETA AÑADIDA!
				// Reseteamos todos los estados visuales internos del modal a su estado por defecto.
				this.correctionStatusButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('selected', 'correction-status-button'));
				this.correctionReasonsContainer.querySelectorAll('.reason-button').forEach(btn => btn.classList.remove('selected'));
				this.correctionReasonButtons.querySelectorAll('.correction-reason-button').forEach(btn => btn.classList.remove('selected'));
				this.correctionReasonsContainer.classList.add('hidden'); // Aseguramos que las razones estén ocultas al inicio.			
				
			    // Siempre que se oculta este modal, limpiamos el estado de desbloqueo.
			    this.clearUnlockedState();
				UI.render();
			},	

		    clearUnlockedState: function() {
		        if (UIState.unlockedScheduleId) {
		            const unlockedButton = this.pharmacologicalIndicationsTable.querySelector('.ring-2');
		            if (unlockedButton) {
		                unlockedButton.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-1');
		            }
		            UIState.unlockedScheduleId = null;
		        }
		    },
		
		    setUnlockedState: function(button, compositeId) {
		        // Primero, limpiamos cualquier otro botón que pudiera estar desbloqueado.
		        this.clearUnlockedState();
		        
		        // Luego, aplicamos el nuevo estado.
		        UIState.unlockedScheduleId = compositeId;
		        button.classList.add('ring-2', 'ring-blue-500', 'ring-offset-1');
		    },
			
		    showEditScheduleModal: function() {
		        const { indication, schedule } = UIState.selectedSchedule;
		        
				const formattedOriginalTime = Utils.formatScheduleTime(schedule.dateTime);
				this.editScheduleSubtitle.textContent = `${indication.indication} (Horario original: ${formattedOriginalTime})`;
		
		        const scheduleDate = Utils.parseISOLocal(schedule.dateTime);
		        this.editScheduleDateInput.value = `${scheduleDate.getFullYear()}-${String(scheduleDate.getMonth() + 1).padStart(2, '0')}-${String(scheduleDate.getDate()).padStart(2, '0')}`;
		        this.editScheduleTimeInput.value = `${String(scheduleDate.getHours()).padStart(2, '0')}:${String(scheduleDate.getMinutes()).padStart(2, '0')}`;
		
		        this.editScheduleModal.classList.remove('hidden');
		    },
		
		    hideEditScheduleModal: function() {
		        this.editScheduleModal.classList.add('hidden');
		        UIState.selectedSchedule = null;
		    },
			
		    setCorrectionModalMode: function(mode) { // mode puede ser 'correct' o 'delete'
		        const isDeleteMode = mode === 'delete';
		
		        // Cambiar visibilidad de la sección de corrección
		        this.correctionModeSection.classList.toggle('hidden', isDeleteMode);
		
		        // Cambiar texto de la etiqueta de razón
		        this.correctionReasonLabel.textContent = isDeleteMode ? 'Motivo del Borrado (Obligatorio)' : 'Motivo de la Corrección (Obligatorio)';
		
		        // Cambiar visibilidad de los botones de la izquierda
		        this.correctionModalDeleteBtn.classList.toggle('hidden', isDeleteMode);
		        this.correctionModalBackBtn.classList.toggle('hidden', !isDeleteMode);
		
		        // Cambiar el botón de guardado principal
		        this.correctionModalSaveBtn.textContent = isDeleteMode ? 'Confirmar Borrado' : 'Guardar Corrección';
		        this.correctionModalSaveBtn.classList.toggle('bg-blue-600', !isDeleteMode);
		        this.correctionModalSaveBtn.classList.toggle('hover:bg-blue-700', !isDeleteMode);
		        this.correctionModalSaveBtn.classList.toggle('bg-red-600', isDeleteMode);
		        this.correctionModalSaveBtn.classList.toggle('hover:bg-red-700', isDeleteMode);
		
		        // Limpiar selección de motivo si cambiamos de modo
		        this.correctionReasonButtons.querySelectorAll('button.selected').forEach(btn => btn.classList.remove('selected'));
		    },
		
			
		    showSosHistoryModal: function(indication) {
		        this.sosHistorySubtitle.textContent = indication.indication;
		        this.sosHistoryTableBody.innerHTML = ''; // Limpiamos la tabla
		
		        const role = UIState.currentRole;
		        const canCorrect = role === 'enfermera' || role === 'tens';
		
		        // Actualizamos el encabezado de la tabla dinámicamente
		        const tableHead = this.sosHistoryModal.querySelector('thead');
		        tableHead.innerHTML = `
		            <tr>
		                <th class="p-2 font-medium">Fecha / Hora</th>
		                <th class="p-2 font-medium">Estado</th>
		                <th class="p-2 font-medium">Razón / Obs.</th>
		                ${canCorrect ? '<th class="p-2 font-medium">Acción</th>' : ''}
		            </tr>
		        `;			
		
				(indication.sosHistory || []).forEach(originalEntry => {
					// ¡LÓGICA CORREGIDA! Obtenemos el estado efectivo para cada entrada.
					const effectiveEntry = Utils.getEffectiveAdminData(originalEntry);
		
					const row = document.createElement('tr');
					const statusText = effectiveEntry.status === 'done' ? 'Administrado' : 'No Administrado';
					const statusColor = effectiveEntry.status === 'done' ? 'text-green-600' : 'text-red-600';
					const reasonText = effectiveEntry.reason || effectiveEntry.observations || 'N/A';
		
					const [year, month, day] = effectiveEntry.adminDate.split('-');
					const formattedDate = `${day}-${month}-${year.slice(-2)}`;
					
					const actionCellHTML = canCorrect 
		                ? `<td class="p-2"><button class="correct-sos-btn text-blue-600 hover:text-blue-800 text-sm font-medium" data-history-id="${originalEntry.id}" data-indication-id="${indication.id}">Corregir</button></td>`
		                : '';

		            // ¡LÓGICA AÑADIDA! Generamos el ícono de historial si es necesario.
		            const historyIconHTML = this.renderCorrectionHistoryIcon(originalEntry);

					row.innerHTML = `
						<td class="p-2 flex items-center">${formattedDate} ${effectiveEntry.adminTime} ${historyIconHTML}</td> 
						<td class="p-2 font-medium ${statusColor}">${statusText}</td>
						<td class="p-2 text-gray-600">${reasonText}</td>
						${actionCellHTML}
						</td>
					`;
					this.sosHistoryTableBody.appendChild(row);
				});
		
		        this.sosHistoryModal.classList.remove('hidden');
		    },
		
		    hideSosHistoryModal: function() {
		        this.sosHistoryModal.classList.add('hidden');
		    },
			
		    showConfirmActionModal: function(config) {
		        this.confirmActionTitle.textContent = config.title;
		        this.confirmActionMessage.textContent = config.message;
		
		        // Lógica para mostrar/ocultar y configurar botones
		        this.confirmActionCancelBtn.textContent = config.cancelText || 'Cancelar';
		        this.confirmActionCancelBtn.classList.toggle('hidden', !config.cancelText);
		
		        this.confirmActionDiscardBtn.textContent = config.discardText || 'Descartar';
		        this.confirmActionDiscardBtn.classList.toggle('hidden', !config.discardText);
		
		        this.confirmActionSaveBtn.textContent = config.saveText || 'Guardar';
		        this.confirmActionSaveBtn.classList.toggle('hidden', !config.saveText);
		
		        this.confirmActionModal.classList.remove('hidden');
		    },
		
		    hideConfirmActionModal: function() {
		        this.confirmActionModal.classList.add('hidden');
		        UIState.pendingAction = null; // Limpiamos la acción pendiente
		    },
			
		    switchToButtonView: function(indicationId) {
		        const row = this.pharmacologicalIndicationsTable.querySelector(`tr[data-id="${indicationId}"]`);
		        if (!row) return;
		
		        const buttonsContainer = row.querySelector('.schedule-buttons-container');
		        const scheduleInput = row.querySelector('.schedule-input');
		        const editAllButton = row.querySelector('.edit-all-schedules-btn');
		
		        if (buttonsContainer && scheduleInput && editAllButton) {
		            scheduleInput.classList.add('hidden');
		            buttonsContainer.classList.remove('hidden');
		            editAllButton.classList.remove('hidden');
		        }
		    },
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA RENDERIZAR EL ÍCONO DE HISTORIAL ---
		    /**
		     * Genera el HTML para un ícono de historial si el registro ha sido corregido.
		     * @param {object} originalAdminData El objeto de registro original.
		     * @returns {string} El string HTML del ícono o un string vacío.
		     */
		    renderCorrectionHistoryIcon: function(originalAdminData) {
		        if (!originalAdminData || !originalAdminData.isCorrected) {
		            return ''; // No mostrar nada si no hay correcciones
		        }
		
		        const tooltipText = Utils.escapeHTML(Utils.formatCorrectionHistoryTooltip(originalAdminData));
		        const iconSVG = `<svg xmlns="http://www.w.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-pen"><path d="M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v5"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10.4 12.6a2 2 0 1 1 3 3L8 21l-4 1 1-4Z"/></svg>`;
		
		        // Usamos un 'span' con la clase 'tooltip-wrapper' para que el tooltip funcione.
		        // El tooltip leerá el atributo 'data-tooltip-text'.
		        return `
		            <span class="tooltip-wrapper ml-2 text-gray-400 hover:text-blue-600" data-tooltip-text="${tooltipText}">
		                ${iconSVG}
		            </span>
		        `;
		    },
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA RENDERIZAR EL ÍCONO DE HISTORIAL SOS ---
		    /**
		     * Genera el HTML para un ícono de historial SOS si la indicación tiene registros.
		     * @param {object} indication El objeto de indicación completo.
		     * @param {boolean} isEditing Si la enfermera está en modo de edición.
		     * @returns {string} El string HTML del ícono o un string vacío.
		     */
		    renderSosHistoryIcon: function(indication, isEditing) {
		        // No mostrar el ícono en modo edición o si no hay historial.
		        if (isEditing || (indication.sosHistory || []).length === 0) {
		            return '';
		        }
		
		        return `
		            <button class="sos-history-btn text-gray-400 hover:text-blue-600 ml-2" data-indication-id="${indication.id}" title="Ver historial SOS">
		                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-history"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/></svg>
		            </button>
		        `;
		    },			
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA RENDERIZAR BOTONES HUÉRFANOS ---
		    /**
		     * Genera el HTML para un botón de horario huérfano (no clickeable pero con tooltip).
		     * @param {object} indication El objeto de indicación.
		     * @param {object} schedule El objeto de horario huérfano.
		     * @returns {string} El string HTML del componente.
		     */
		    renderOrphanedScheduleButton: function(indication, schedule) {
		        let wrapperAttributes = `
		            class="inline-block tooltip-wrapper"
		            title="Horario anterior/cancelado"
		            data-schedule-id="${schedule.id}" 
		            data-indication-id="${indication.id}"
		        `;
		        let buttonText = '';
		        let statusClasses = 'bg-gray-200 text-gray-400 opacity-75';
		
		        if (schedule.id === 'SOS') {
		            const history = (indication.sosHistory || [])
		                .filter(entry => entry.status === 'done')
		                .map(entry => `${entry.adminDate} ${entry.adminTime}`)
		                .join(',');
		            if (history) {
		                wrapperAttributes += ` data-history="${history}"`;
		            }
		            statusClasses = 'bg-indigo-200 text-indigo-500 opacity-75';
		            buttonText = 'SOS';
		        } else {
		            const originalAdminData = (indication.administered && indication.administered[schedule.id]) || null;
		            const effectiveAdminData = Utils.getEffectiveAdminData(originalAdminData) || {};
		            const status = effectiveAdminData.status;
		
		            if (status === 'done') statusClasses = 'bg-green-200 text-green-600 opacity-75';
		            else if (status === 'not-done') statusClasses = 'bg-red-200 text-red-600 opacity-75';
		
		            wrapperAttributes += `
		                data-observations="${effectiveAdminData.observations || ''}"
		                data-reason="${effectiveAdminData.reason || ''}"
		                data-admin-time="${effectiveAdminData.adminTime || ''}"
		                data-admin-date="${effectiveAdminData.adminDate || ''}"
		            `;
		            buttonText = Utils.formatScheduleTime(schedule.dateTime);
		        }
		
		        return `
		            <span ${wrapperAttributes}>
		                <button class="schedule-button px-2 py-1 rounded-md text-sm font-medium relative ${statusClasses} cursor-not-allowed pointer-events-none" disabled>
		                    ${buttonText}
		                </button>
		            </span>
		        `;
		    },			
			
			showToast: function(message) {
				let toast = document.querySelector('.toast');
				if (!toast) {
					toast = document.createElement('div');
					toast.className = 'toast';
					document.body.appendChild(toast);
				}
				toast.textContent = message;
				toast.classList.add('show');
				setTimeout(() => { toast.classList.remove('show'); }, 2500);
			}
		};

		// =================================================================================
		// MÓDULO PRINCIPAL DE LA APLICACIÓN (Controlador)
		// =================================================================================
		const App = {
			isCreatingRow: false,
			init: async function() {
			    try {
			        await AppState.initDB();
			        await AppState.loadMeta();
			        
			        const todayString = new Date().toISOString().split('T')[0];
			        UIState.viewingDate = AppState.activeSheetDate;
			
			        // ¡LÓGICA DEL BANNER!
			        // Comprobamos si la hoja activa es de un día anterior.
			        if (AppState.activeSheetDate < todayString) {
			            UIState.showOldSheetWarning = true; // Nueva bandera de estado
			        } else {
			            UIState.showOldSheetWarning = false;
			        }
			
			        const sheet = await AppState.loadSheet(UIState.viewingDate);
			        if (!sheet) {
			            this.populateWithDefaultData(UIState.viewingDate);
			            await AppState.saveCurrentSheet();
			            await AppState.saveMeta();
			        }
			        
			        UI.init();
			        this.initEventListeners();
			        UI.render();
			    } catch (error) {
			        console.error("Error initializing app:", error);
			    }
			},
			// MODIFICA EL LOG
			logChange: function(actionType, detailsObject) {
			    const newLogEntry = {
			        id: `log_${new Date().getTime()}`,
			        timestamp: new Date().toISOString(),
			        role: UIState.currentRole,
			        // A futuro, aquí iría el ID del usuario logueado
			        // userId: Session.getCurrentUser().id, 
			        action: actionType,
			        details: detailsObject
			    };
			    if (!AppState.currentSheet.data.changeLog) AppState.currentSheet.data.changeLog = [];
			    AppState.currentSheet.data.changeLog.push(newLogEntry);
			},
			// MODO EDICIÓN DE ENFERMERÍA
			enterNurseEditMode: function() {
				if (UIState.editingLock.isLocked) {
					return UI.showInfoModal('Acción Bloqueada', `No se puede editar ahora. El rol '${UIState.editingLock.lockedBy}' está realizando cambios.`);
				}
				UIState.editingLock = { isLocked: true, lockedBy: 'enfermera' };
				UIState.nurseEditingMode = true;
			    // Creamos tanto la copia de seguridad como la copia de trabajo
			    UIState.nurseScheduleBackup = Utils.deepClone(AppState.currentSheet.data.pharmacologicalIndications);
			    UIState.nurseEditingData = Utils.deepClone(AppState.currentSheet.data.pharmacologicalIndications);
				UI.render();
			},
			
		    saveScheduleEdit: function() {
		        const { indication, schedule } = UIState.selectedSchedule;
		        const newDate = UI.editScheduleDateInput.value;
		        const newTime = UI.editScheduleTimeInput.value;
		        const newDateTime = Utils.toLocalISOString(new Date(`${newDate}T${newTime}`));
		
		        // Validación de duplicados
		        const hasDuplicate = (indication.schedules || []).some(s => s.id !== schedule.id && s.dateTime === newDateTime);
		        if (hasDuplicate) {
		            return UI.showInfoModal('Horario Duplicado', `Ya existe un horario programado a las ${newTime} para esta indicación.`);
		        }
		
		        // Actualizar el horario en la copia temporal
		        const scheduleInCopy = UIState.nurseEditingData
		            .find(i => i.id === indication.id)?.schedules
		            .find(s => s.id === schedule.id);
		
		        if (scheduleInCopy) {
		            scheduleInCopy.dateTime = newDateTime;
		            scheduleInCopy.id = newDateTime; // Actualizamos el ID para que coincida
		        }
		
		        // Marcar la indicación como "sucia"
		        const indicationInCopy = UIState.nurseEditingData.find(i => i.id === indication.id);
		        if (indicationInCopy) indicationInCopy.isDirty = true;
		
		        UI.hideEditScheduleModal();
		        UI.render(); // Re-renderizar para la actualización inmediata
		    },
		
		    deleteSingleSchedule: function() {
		        // Usaremos el info-modal como confirmación reutilizable
		        // (Lógica para configurar y mostrar un modal de confirmación iría aquí)
		        if (!confirm("¿Estás seguro de que quieres eliminar este horario?")) return;
		
		        const { indication, schedule } = UIState.selectedSchedule;
		
		        // Eliminar el horario de la copia temporal
		        const indicationInCopy = UIState.nurseEditingData.find(i => i.id === indication.id);
		        if (indicationInCopy) {
		            indicationInCopy.schedules = (indicationInCopy.schedules || []).filter(s => s.id !== schedule.id);
		            indicationInCopy.isDirty = true;
				
		            // ¡LÓGICA CLAVE AÑADIDA!
		            // Comprobamos si, después de eliminar, ya no quedan horarios activos.
		            const hasActiveSchedules = indicationInCopy.schedules.some(s => s.status === 'active');
		
		            // Si no quedan activos y la indicación no está suspendida, la pasamos a pendiente.
		            if (!hasActiveSchedules && indicationInCopy.status !== Config.INDICATION_STATUS.SUSPENDED) {
		                indicationInCopy.status = Config.INDICATION_STATUS.PENDING_SCHEDULE;
		            }							
		        }
		
		        UI.hideEditScheduleModal();
		        UI.render();
		    },
			
			cancelNurseEditMode: function(discard = false) {
				// Lógica para el modal de confirmación si hay cambios
				UIState.editingLock = { isLocked: false, lockedBy: null };
				UIState.nurseEditingMode = false;
			    UIState.nurseScheduleBackup = null; // Descartamos ambas copias
			    UIState.nurseEditingData = null;
				UI.render();
			},
	
			finalizeNurseEditMode: async function() {
			    const originalIndications = UIState.nurseScheduleBackup;
			    const finalIndications = UIState.nurseEditingData; // Esta es ahora nuestra fuente de verdad
			    const changesForLog = [];
			
			    // 1. Generar el log comparando la versión final con la copia de seguridad
			    finalIndications.forEach(finalInd => {
			        if (finalInd.isDirty) {
			            const originalInd = originalIndications.find(o => o.id === finalInd.id) || {};
			            const oldSchedulesStr = (originalInd.schedules || []).filter(s => s.status === 'active').map(s => Utils.formatScheduleTime(s.dateTime)).join('-');
			            const newSchedulesStr = (finalInd.schedules || []).filter(s => s.status === 'active').map(s => Utils.formatScheduleTime(s.dateTime)).join('-');
			
			            if (oldSchedulesStr !== newSchedulesStr) {
			                changesForLog.push({ indicationId: finalInd.id, indicationName: finalInd.indication, oldSchedules: oldSchedulesStr, newSchedules: newSchedulesStr });
			            }
			        }
			    });
			
			    if (changesForLog.length > 0) {
			        this.logChange(Config.LOG_ACTIONS.UPDATE_SCHEDULES, { changes: changesForLog });
			    }
			
			    // 2. Commit final: Guardar la copia de trabajo como el nuevo estado principal
			    AppState.currentSheet.data.pharmacologicalIndications = finalIndications.map(ind => {
			        // Limpiamos las propiedades temporales antes de guardar
			        delete ind.schedulesString;
			        delete ind.isDirty;
			        return ind;
			    });
			    
			    // 3. Resetear el estado de la UI
			    UIState.editingLock = { isLocked: false, lockedBy: null };
			    UIState.nurseEditingMode = false;
			    UIState.nurseScheduleBackup = null;
			    UIState.nurseEditingData = null;
			    
			    // 4. Guardar y notificar
			    AppState.updateCurrentSheetData({});
			    UI.showToast('Horarios actualizados exitosamente');
			},
			
			// ENTRAR A MODO EDICIÓN -- MÉDICO
			enterDoctorEditMode: function() {
				if (UIState.editingLock.isLocked) {
					return UI.showInfoModal('Acción Bloqueada', `No se puede editar ahora. El rol '${Config.ROLES[UIState.editingLock.lockedBy]}' está realizando cambios.`);
				}
				UIState.editingLock = { isLocked: true, lockedBy: 'medico' };
				UIState.doctorHasDraft = true;
				// Creamos la copia de seguridad y la copia de trabajo
				UIState.doctorScheduleBackup = Utils.deepClone(AppState.currentSheet.data);
				UIState.doctorEditingData = Utils.deepClone(AppState.currentSheet.data);
				UI.render();
			},

			// AUTORIZAR -- MÉDICO
			authorizeDoctorDraft: function() {
				const finalData = UIState.doctorEditingData;

				// Lógica de autorización sobre la copia de trabajo
				finalData.pharmacologicalIndications.forEach(ind => {
					if (ind.status === Config.INDICATION_STATUS.DRAFT || ind.status === Config.INDICATION_STATUS.PENDING_SCHEDULE) {
						const hasActiveSchedules = Array.isArray(ind.schedules) && ind.schedules.some(s => s.status === 'active');
						ind.status = hasActiveSchedules ? Config.INDICATION_STATUS.ACTIVE : Config.INDICATION_STATUS.PENDING_SCHEDULE;
					}
				});

				// Commit final: La copia de trabajo se convierte en el nuevo estado principal
				AppState.currentSheet.data = finalData;

				// Resetear estado de la UI
				UIState.editingLock = { isLocked: false, lockedBy: null };
				UIState.doctorHasDraft = false;
				UIState.doctorScheduleBackup = null;
				UIState.doctorEditingData = null;
				
				AppState.updateCurrentSheetData({}); // Guarda y renderiza
			},

			cancelDoctorDraft: function() {
			    // ¡LÓGICA MEJORADA!
			    // 1. Revertimos el estado principal usando la copia de seguridad.
			    // Esto anula cualquier cambio que se haya hecho accidentalmente en AppState.
			    if (UIState.doctorScheduleBackup) {
			        AppState.currentSheet.data = Utils.deepClone(UIState.doctorScheduleBackup);
			    }
			
			    // 2. Reseteamos el estado de la UI.
			    UIState.editingLock = { isLocked: false, lockedBy: null };
			    UIState.doctorHasDraft = false;
			    UIState.doctorScheduleBackup = null;
			    UIState.doctorEditingData = null;
			
			    // 3. Guardamos el estado revertido y re-renderizamos.
			    AppState.updateCurrentSheetData({});
			},	

			// AGREGAR INDICACIONES
			addNewIndication: function() {
			    // ¡LÓGICA CORREGIDA! Determinamos la fuente de datos correcta.
			    const targetArray = UIState.doctorHasDraft 
			        ? UIState.doctorEditingData.pharmacologicalIndications 
			        : AppState.currentSheet.data.pharmacologicalIndications;
			
			    const newId = targetArray.length > 0
			        ? Math.max(...targetArray.map(i => i.id)) + 1
			        : 1;
			
			    const newIndication = {
			        id: newId,
			        indication: '',
			        route: null,
			        schedules: [],
			        status: Config.INDICATION_STATUS.DRAFT,
			        administered: {},
			        sosHistory: []
			    };
			
			    targetArray.push(newIndication);
			    
			    // Si estamos en modo borrador, solo re-renderizamos.
			    // Si no, guardamos y re-renderizamos.
			    if (UIState.doctorHasDraft) {
			        UI.render();
			    } else {
			        AppState.updateCurrentSheetData({});
			    }
			},
			
			// CAMBIAR DE DÍA
			changeDay: async function(offset) {
				const currentDate = new Date(UIState.viewingDate);
				currentDate.setDate(currentDate.getDate() + offset);
				const newDateString = currentDate.toISOString().split('T')[0];

				UIState.viewingDate = newDateString;
				const sheet = await AppState.loadSheet(newDateString);
				
				// Actualizamos el estado de la UI basándonos en lo que encontramos
				UIState.isHistoryView = !!sheet && newDateString !== AppState.activeSheetDate;
				UIState.isFutureEmptyView = !sheet && newDateString > new Date().toISOString().split('T')[0];
				
				UI.render();
			},
			
			// INDICACIONES VERBALES
			processVerbalIndication: function(id, status) {
				const indicationIndex = AppState.currentSheet.data.verbalIndications.findIndex(ind => ind.id === id);
				if (indicationIndex === -1) return; // No se encontró la indicación

				// 1. Sacamos la indicación de la lista de pendientes
				const [indication] = AppState.currentSheet.data.verbalIndications.splice(indicationIndex, 1);

				// 2. Creamos el nuevo objeto para la lista de procesadas
				const processedIndication = {
					...indication,
					status: status, // 'validated' o 'rejected'
					processedTime: new Date().toTimeString().slice(0, 5),
					validatedBy: Config.ROLES[UIState.currentRole]
				};

				// 3. La añadimos a la lista de procesadas
				AppState.currentSheet.data.processedVerbalIndications.push(processedIndication);

				// 4. Forzamos un guardado y re-renderizado
				AppState.updateCurrentSheetData({});
			},
			
			// INGRESAR HORARIOS
			handleScheduleInputBlur: function(inputElement) {
				// Esta función ahora solo funciona en el modo de edición de la enfermera
				if (!UIState.nurseEditingMode) return;

				const changedIndications = UIState.nurseEditingData;
				if (!changedIndications) return;
				
				// ¡LÍNEA AÑADIDA! Declaramos 'schedulesString' obteniendo el valor del input.
				const schedulesString = inputElement.value;
				const id = parseInt(inputElement.dataset.id);
				const indication = changedIndications.find(ind => ind.id === id);
				if (!indication) return;

		        // Obtenemos el string de horarios original desde la copia de seguridad
		        const originalIndication = UIState.nurseScheduleBackup.find(o => o.id === id) || {};
		        const activeOriginalSchedules = (originalIndication.schedules || []).filter(s => s.status === 'active');
		        const originalSchedulesString = activeOriginalSchedules.map(s => Utils.formatScheduleTime(s.dateTime)).join('-');
				const finalSchedules = [];
		
				// ¡LÓGICA CLAVE! Comparamos el string original con el nuevo.
				if (Utils.areScheduleStringsEquivalent(originalSchedulesString, schedulesString)) {
					// Si son equivalentes, no hay cambios reales.
					// Simplemente revertimos la indicación en la copia de trabajo a su estado original
					// para deshacer cualquier cambio de formato y volvemos a renderizar.
					const index = changedIndications.findIndex(i => i.id === id);
					if (index > -1) {
						changedIndications[index] = Utils.deepClone(originalIndication);
					}
				} else {
					// Si son diferentes, marcamos como sucio y reconciliamos.
					indication.schedulesString = schedulesString;
					indication.isDirty = true;
			 
					const originalSchedules = originalIndication.schedules || [];
					 
					// 1. Usamos nuestra función de ayuda para obtener el array de nuevos horarios.
					const processedNewSchedules = Utils.processSchedulesString(schedulesString, UIState.viewingDate);
			
					// 2. ¡CORRECCIÓN CLAVE! Creamos el Set a partir del array que acabamos de obtener.
					const newScheduleDateTimes = new Set(processedNewSchedules.map(s => s.dateTime));
			
					const processedDateTimes = new Set();
			
					// 3. Iterar sobre los horarios ORIGINALES...
					originalSchedules.forEach(origSchedule => {
						const isAdministered = originalIndication.administered && originalIndication.administered[origSchedule.id] || (origSchedule.id === 'SOS' && (originalIndication.sosHistory || []).length > 0);
			
						if (newScheduleDateTimes.has(origSchedule.dateTime)) {
							finalSchedules.push({ ...origSchedule, status: 'active' });
							processedDateTimes.add(origSchedule.dateTime);
						} 
						else if (isAdministered) {
							finalSchedules.push({ ...origSchedule, status: Config.INDICATION_STATUS.CANCELLED });
						}
					});
			
					// 4. Iterar sobre el nuevo plan...
					processedNewSchedules.forEach(newSchedule => {
						if (!processedDateTimes.has(newSchedule.dateTime)) {
							finalSchedules.push(newSchedule);
						}
					});
		
					indication.schedules = finalSchedules;
				}
				
		        // --- Lógica de Actualización de Estado ---
		        const hasActiveSchedules = finalSchedules.some(s => s.status === 'active');
		        // Si una indicación que era activa se queda sin horarios activos,
		        // la pasamos a PENDING_SCHEDULE. Esto la marcará como necesitando acción.
		        if (indication.status === Config.INDICATION_STATUS.ACTIVE && !hasActiveSchedules) {
		            indication.status = Config.INDICATION_STATUS.PENDING_SCHEDULE;
		        } 
		        // Si una indicación que era pendiente ahora tiene horarios, la activamos.
		        else if (indication.status === Config.INDICATION_STATUS.PENDING_SCHEDULE && hasActiveSchedules) {
		            indication.status = Config.INDICATION_STATUS.ACTIVE;
		        }		
			
		        // ¡CORRECCIÓN CLAVE! Reseteamos la bandera de edición masiva
		        // para que el siguiente renderizado muestre los botones.
		        indication.isEditingMassively = false;
			
				UI.render(); // Ahora el re-render dibujará la vista correcta
			},
			
			// BOTONES HORARIOS
			handleScheduleClick: function(e) {
				const button = e.target.closest('.schedule-button');
				if (!button) return;

				UI.hideTooltip();

				const indicationId = parseInt(button.dataset.indicationId);
				const scheduleId = button.dataset.scheduleId;
				if (isNaN(indicationId)) return;

				const role = UIState.currentRole;
				if (role === 'medico') return;

				const sourceData = UIState.nurseEditingMode ? UIState.nurseEditingData : AppState.currentSheet.data.pharmacologicalIndications;
				const indication = sourceData.find(ind => ind.id === indicationId);
				if (!indication) return;

				const schedule = (indication.schedules || []).find(s => s.id === scheduleId);
				if (!schedule) return;

				// --- FUNCIÓN DE AYUDA INTERNA para continuar la acción ---
				const proceedWithAction = () => {
					if (UIState.nurseEditingMode) {
						if (schedule.id === 'SOS' || schedule.status !== 'active') return;
						if (indication.administered && indication.administered[schedule.id]) return;
						if (indication.status === Config.INDICATION_STATUS.SUSPENDED) return;
						UIState.selectedSchedule = { indication, schedule };
						UI.showEditScheduleModal();
					} else {
						const originalAdminData = (schedule.id === 'SOS')
							? ((indication.sosHistory || []).length > 0 ? indication.sosHistory[indication.sosHistory.length - 1] : null)
							: (indication.administered && indication.administered[scheduleId]);
						
						if (originalAdminData && schedule.id != 'SOS') {
							const compositeId = `${indicationId}-${scheduleId}`;
							if (UIState.unlockedScheduleId === compositeId) {
								UI.clearUnlockedState();
			                    if (indication.status === Config.INDICATION_STATUS.SUSPENDED) {
			                        UIState.pendingAction = { 
			                            execute: () => {
			                                const context = scheduleId;
			                                UI.showCorrectionModal(indication, context);
			                            }
			                        };
			                        UI.showConfirmActionModal({
			                            title: 'Indicación Suspendida',
			                            message: `Atención: La indicación "${indication.indication}" está suspendida. ¿Deseas continuar con la corrección?`,
			                            cancelText: 'Cancelar',
			                            saveText: 'Continuar'
			                        });
			                    } else {
			                        const context = scheduleId;
			                        UI.showCorrectionModal(indication, context);
			                    }
							} else {
								// PRIMER CLIC: Solo desbloquea
								UI.setUnlockedState(button, compositeId);
							}
						} else {
							// Lógica para abrir pop-over de administración
			                const openAdminPopover = () => {
			                    UI.clearUnlockedState();
			                    if (UI.scheduleModalButton === button) {
			                        UI.hideScheduleModal();
			                    } else {
			                        UIState.selectedSchedule = { indicationId, scheduleId, dateTime: schedule.dateTime, status: null, reason: null, observations: '' };
			                        UI.showScheduleModal(button);
			                    }
			                };
			
			                if (indication.status === Config.INDICATION_STATUS.SUSPENDED) {
			                    UIState.pendingAction = { execute: openAdminPopover };
			                    UI.showConfirmActionModal({
			                        title: 'Indicación Suspendida',
			                        message: `Atención: La indicación "${indication.indication}" está suspendida. ¿Deseas continuar con la administración?`,
			                        cancelText: 'Cancelar',
			                        saveText: 'Continuar'
			                    });
			                } else {
			                    openAdminPopover();
			                }
						}
					}
				};
			    // La ejecución ahora siempre empieza con proceedWithAction
			    proceedWithAction();
			},		
			
			deleteAdminRecord: function(reasonForDeletion) {
				const { indicationId, scheduleId, isSos, sosHistoryId } = UIState.correctionContext;
				const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
				if (!indication) return;

				let deletedState = null;
				let targetRecord = null;

				if (isSos) {
					targetRecord = (indication.sosHistory || []).find(h => h.id === sosHistoryId);
					if (targetRecord) {
						deletedState = Utils.deepClone(targetRecord);
						indication.sosHistory = indication.sosHistory.filter(h => h.id !== sosHistoryId);
					}
				} else {
					targetRecord = indication.administered[scheduleId];
					if (targetRecord) {
						deletedState = Utils.deepClone(targetRecord);
						delete indication.administered[scheduleId];
					}
				}

				if (deletedState) {
					this.logChange(Config.LOG_ACTIONS.DELETE_ADMINISTRATION, { 
						indicationId, scheduleId, deletedState,
						reason: reasonForDeletion
					});
					AppState.updateCurrentSheetData({});
					UI.hideCorrectionModal();
					UI.showToast('Registro borrado exitosamente');
				}
			},
			
			saveCorrection: function() {
				const { indicationId, scheduleId, isSos, sosHistoryId } = UIState.correctionContext;
				const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
				
			    const originalRecord = isSos
			        ? (indication.sosHistory || []).find(h => h.id === sosHistoryId)
			        : indication.administered[scheduleId];
			    
			    const effectivePreviousState = Utils.getEffectiveAdminData(originalRecord);
			 
				// 1. Recolectar datos del formulario
				const newStatus = UI.correctionStatusButtons.querySelector('.selected')?.dataset.status;
			    // ¡LÓGICA CORREGIDA! Solo leemos la razón si el estado es 'not-done'.
			    const newReasonForNoAdmin = (newStatus === 'not-done')
			        ? UI.correctionReasonsContainer.querySelector('.reason-button.selected')?.dataset.reason
			        : null;
			    const newReasonForCorrection = UI.correctionReasonButtons.querySelector('.correction-reason-button.selected')?.dataset.correctionReason;
			
			    // 2. Construir el objeto del nuevo estado a partir del formulario
			    const newState = {
			        status: newStatus,
			        reason: newReasonForNoAdmin,
			        observations: UI.correctionObsTextarea.value,
			        adminDate: UI.correctionDateInput.value,
			        adminTime: UI.correctionTimeInput.value
			    };
			
			    // 3. ¡LÓGICA CLAVE! Comparamos el estado previo con el nuevo.
			    const keysToCompare = ['status', 'reason', 'observations', 'adminDate', 'adminTime'];
			    const hasChanges = Utils.areObjectsDifferent(effectivePreviousState, newState, keysToCompare);
			 
			    // 4. Validar campos obligatorios
			    if (!newStatus) {
			        return UI.showInfoModal('Campos Incompletos', 'Por favor, seleccione un nuevo estado (Administrado o No Administrado).');
				}
			    // Si hubo cambios, el motivo de la corrección es obligatorio.
			    if (hasChanges && !newReasonForCorrection) {
			        return UI.showInfoModal('Campos Incompletos', 'Se detectaron cambios. Por favor, seleccione un motivo para la corrección.');
			    }
			    if (newStatus === 'not-done' && !newReasonForNoAdmin) {
			        return UI.showInfoModal('Campos Incompletos', 'Por favor, seleccione una razón de no administración.');
			    }
			
			    // Si no hubo cambios, simplemente cerramos el modal.
			    if (!hasChanges) {
			        // hideCorrectionModal ahora también se encarga de limpiar el estado de desbloqueo.
			        UI.hideCorrectionModal();
			        return;
			    }
			 	 
				const correctionEntry = {
					id: `corr_${new Date().getTime()}`,
					timestamp: new Date().toISOString(),
					correctedBy: Config.ROLES[UIState.currentRole],
					newState: newState,
					reasonForCorrection: newReasonForCorrection
				};
				
			    // 5. Actualizar el estado (lógica sin cambios)
			    if (isSos) {
			        originalRecord.isCorrected = true;
			        if (!originalRecord.corrections) originalRecord.corrections = [];
			        originalRecord.corrections.push(correctionEntry);
			    } else {
			        originalRecord.isCorrected = true;
			        if (!originalRecord.corrections) originalRecord.corrections = [];
			        originalRecord.corrections.push(correctionEntry);
			    }
				
			    // 6. Generar el log
		        this.logChange(Config.LOG_ACTIONS.CORRECT_ADMINISTRATION, {
		            indicationId, scheduleId,
		            previousState: { status: effectivePreviousState.status, adminTime: effectivePreviousState.adminTime },
		            newState: newState,
		            reasonForCorrection: newReasonForCorrection
		        });
			 
				// 7. Guardar, renderizar y notificar
				AppState.updateCurrentSheetData({});
				UI.hideCorrectionModal();
				UI.showToast('Registro corregido exitosamente');
			},
			
		    handleNavigationAttempt: function(action) {
		        const hasChanges = UIState.doctorHasDraft || UIState.nurseEditingMode;
		
		        if (!hasChanges) {
		            action.execute(); // Si no hay cambios, ejecuta la acción inmediatamente.
		            return;
		        }
		
		        // Si hay cambios, guardamos la acción y mostramos el modal.
		        UIState.pendingAction = action;
		        UI.showConfirmActionModal({
		            title: 'Tienes cambios sin guardar',
		            message: '¿Qué te gustaría hacer con los cambios que has realizado?',
		            cancelText: 'Cancelar',
		            discardText: 'Descartar Cambios',
		            saveText: 'Guardar y Continuar'
		        });
		    },
			
			// CREAR INFORMACIÓN DE EJEMPLO
			populateWithDefaultData: function(dateString) {
				const defaultSheet = {
					date: dateString,
					data: {
						generalIndications: {
							manejo: 'Hasta UTIM', reposo: 'Reposo relativo', regimen: 'Blando picado',
							controlIngesta: 'BCP', apoyoVentilatorio: 'O2 para Saturar 90-92%', balanceHidrico: '+500ml',
							hemoglucotest: 'c/6hrs', rehabilitacion: { knt: true, to: false, fo: true },
							alergias: 'Penicilina', aislamiento: '', cateteres: 'CVC yugular derecho', cup: 'No requiere'
						},
						pharmacologicalIndications: [
							{
								id: 1, indication: 'Paracetamol 1g cada 8 hrs', route: 'VO',
								status: Config.INDICATION_STATUS.ACTIVE,
								schedules: [
									{ id: '2025-08-08T08:00:00.000Z', dateTime: '2025-08-08T08:00:00.000Z', status: 'active' },
									{ id: '2025-08-08T16:00:00.000Z', dateTime: '2025-08-08T16:00:00.000Z', status: 'active' },
									{ id: '2025-08-08T20:00:00.000Z', dateTime: '2025-08-08T20:00:00.000Z', status: 'active' }
								],
								administered: {
									'2025-08-08T08:00:00.000Z': { 
										status: 'done', reason: null, observations: 'Administrado por enfermera', adminTime: '08:05', adminDate: '2025-08-08',
										isCorrected: false,
										corrections: []
									}
								}
							},
							{
								id: 2, indication: 'Omeprazol 40mg al día', route: 'VO',
								status: Config.INDICATION_STATUS.ACTIVE,
								schedules: [
									{ id: '2025-08-08T08:00:00.000Z', dateTime: '2025-08-08T08:00:00.000Z', status: 'active' }
								],
								administered: {
									'2025-08-08T08:00:00.000Z': { 
										status: 'not-done', reason: 'Paciente en examen', observations: 'Salió a TAC de abdomen', adminTime: '08:00', adminDate: '2025-08-08',
										isCorrected: false,
										corrections: []
									}
								}
							},
							{
								id: 4, indication: 'Ondansetrón 4 mg SOS', route: 'EV',
								status: Config.INDICATION_STATUS.ACTIVE,
								schedules: [ { id: 'SOS', dateTime: 'SOS', status: 'active' } ],
								administered: {},
								sosHistory: [] 
							},
							{
								id: 5, indication: 'Enoxaparina 40 mg al día', route: 'SC',
								status: Config.INDICATION_STATUS.PENDING_SCHEDULE,
								schedules: [],
								administered: {}
							}
						],
						
						// Las indicaciones verbales no cambian
						verbalIndications: [
							{ id: 1, indication: 'Metamizol 500mg EV SOS si dolor', time: '14:30', nurse: 'Enfermera González' },
							{ id: 2, indication: 'Tomografía axial computarizada de abdomen y pelvis con contraste', time: '16:00', nurse: 'Enfermera Rojas' }
						],
						processedVerbalIndications: [],
						changeLog: []
					}
				};
			    AppState.currentSheet = defaultSheet;	
			},
			
		    // --- NUEVA FUNCIÓN DE AYUDA PARA NAVEGACIÓN ---
		    /**
		     * Maneja la navegación con la tecla Enter entre una lista de elementos de formulario.
		     * @param {Event} event El objeto de evento keydown.
		     * @param {string} selector El selector CSS para encontrar todos los elementos navegables.
		     */
		    navigateWithEnter: function(event, selector) {
		        event.preventDefault();
		        const elements = Array.from(document.querySelectorAll(selector));
		        const currentIndex = elements.indexOf(document.activeElement);
		
		        if (currentIndex > -1 && currentIndex < elements.length - 1) {
		            // ¡LÓGICA CORREGIDA!
		            // Hacemos blur en el elemento actual para disparar la lógica de guardado/render.
		            document.activeElement.blur();
		            
		            // Usamos setTimeout para poner la acción de 'focus' al final de la cola de eventos.
		            // Esto asegura que se ejecute DESPUÉS de que el re-render haya terminado.
		            setTimeout(() => {
		                // Volvemos a buscar los elementos por si el DOM cambió.
		                const newElements = Array.from(document.querySelectorAll(selector));
		                if (newElements[currentIndex + 1]) {
		                    newElements[currentIndex + 1].focus();
		                }
		            }, 0);
		        } else {
		            // Si es el último, hace blur para guardar/procesar
		            document.activeElement.blur();
		        }
		    },
			
		    handleNewSheetClick: function() {
		        if (UIState.editingLock.isLocked) {
		            return UI.showInfoModal('Acción Bloqueada', `No se puede crear una nueva hoja mientras el rol '${Config.ROLES[UIState.editingLock.lockedBy]}' está realizando cambios.`);
		        }
		        if (UIState.doctorHasDraft) {
		            this.handleNavigationAttempt({
		                execute: () => this.showNewSheetOptions()
		            });
		        } else {
		            this.showNewSheetOptions();
		        }
		    },
		
			showNewSheetOptions: function() {
			    const todayString = new Date().toISOString().split('T')[0];
			    let dateForNewSheet;
			
			    // ¡LÓGICA CORREGIDA!
			    // Si la última hoja activa es de ayer, la nueva hoja es para HOY.
			    if (AppState.activeSheetDate < todayString) {
			        dateForNewSheet = todayString;
			    } else {
			        // Si no, es para la fecha que estamos viendo (un día futuro).
			        dateForNewSheet = UIState.viewingDate;
			    }
			
			    UIState.newSheetDate = dateForNewSheet;
			    UI.newSheetDateDisplay.textContent = Utils.formatDate(UIState.newSheetDate).split(', ')[1];
			    UI.newSheetOptionsModal.classList.remove('hidden');
			},
		
		    createNewSheet: async function(repeatIndications) {
		        const newSheetDate = UIState.newSheetDate;
		        let newGeneralIndications = {
		            manejo: '', reposo: '', regimen: '', controlIngesta: '', apoyoVentilatorio: '',
		            balanceHidrico: '', hemoglucotest: '', rehabilitacion: { knt: false, to: false, fo: false },
		            alergias: '', aislamiento: '', cateteres: '', cup: ''
		        };
		        let newPharmacologicalIndications = [];
		        let carriedOverIds = [];
		
		        if (repeatIndications) {
		            // ¡LÓGICA CORREGIDA! Cargamos la última hoja activa para copiar desde ella.
		            const activeSheet = await AppState.loadSheet(AppState.activeSheetDate);
		            if (activeSheet) {
		                newGeneralIndications = Utils.deepClone(activeSheet.data.generalIndications);
		                const activeIndications = activeSheet.data.pharmacologicalIndications.filter(
		                    ind => ind.status === Config.INDICATION_STATUS.ACTIVE || ind.status === Config.INDICATION_STATUS.PENDING_SCHEDULE
		                );
		                newPharmacologicalIndications = Utils.deepClone(activeIndications).map(ind => {
		                    ind.schedules = [];
		                    ind.administered = {};
		                    ind.sosHistory = [];
		                    ind.status = Config.INDICATION_STATUS.DRAFT;
		                    return ind;
		                });
		                carriedOverIds = newPharmacologicalIndications.map(i => i.id);
		            }
		        }
		
		        // Creamos el nuevo objeto de hoja
		        const newSheet = {
		            date: newSheetDate,
		            data: {
		                generalIndications: newGeneralIndications,
		                pharmacologicalIndications: newPharmacologicalIndications,
		                verbalIndications: [],
		                processedVerbalIndications: [],
		                changeLog: []
		            }
		        };
		
		        // Actualizamos el estado de la aplicación
		        AppState.currentSheet = newSheet;
		        AppState.activeSheetDate = newSheetDate;
		
		        UIState.viewingDate = newSheetDate;
		        UIState.doctorHasDraft = true;
		        UIState.editingLock = { isLocked: true, lockedBy: 'medico' };
		        UIState.isFutureEmptyView = false;
		        UIState.showOldSheetWarning = false;
		
		        this.logChange('CREATE_NEW_SHEET', { newSheetDate, indicationsCarriedOver: carriedOverIds });
		        
		        // Guardamos todo y renderizamos
		        await AppState.saveCurrentSheet();
		        await AppState.saveMeta();
		        
		        UI.newSheetOptionsModal.classList.add('hidden');
		        UI.render();
		        UI.showToast('Nueva hoja creada en modo borrador');
		    },

			// LISTENERS
			initEventListeners: function() {
				UI.roleSelect.addEventListener('change', (e) => {
				    const newRole = e.target.value;
				    // En lugar de ejecutar el cambio directamente, lo pasamos a nuestro interceptor.
				    this.handleNavigationAttempt({
				        type: 'ROLE_CHANGE',
				        payload: newRole,
				        execute: () => {
				            UI.hideScheduleModal();
				            UI.hideTooltip();
				            UIState.currentRole = newRole;
				            UIState.doctorHasDraft = false;
				            UIState.nurseEditingMode = false;
				            AppState.updateCurrentSheetData({});
				        }
				    });
				});
				
				UI.prevDayButton.addEventListener('click', () => {
				    this.handleNavigationAttempt({
				        type: 'DAY_CHANGE',
				        payload: -1,
				        execute: () => this.changeDay(-1)
				    });
				});
				UI.nextDayButton.addEventListener('click', () => {
				    this.handleNavigationAttempt({
				        type: 'DAY_CHANGE',
				        payload: 1,
				        execute: () => this.changeDay(1)
				    });
				});
				
				window.addEventListener('resize', () => {
					// Buscamos TODOS los textareas que necesitan auto-ajuste
					// (tanto en indicaciones generales como en las farmacológicas)
					document.querySelectorAll('.indication-textarea').forEach(textarea => {
						Utils.autoResizeTextarea(textarea);
					});
				});
				
				UI.generalForm.addEventListener('input', (e) => {
					// Sincroniza los textareas
					if (e.target.matches('textarea')) {
						const textarea = e.target;
						const key = textarea.dataset.key;
			            // ¡CORRECCIÓN CLAVE! Modificamos la copia de trabajo.
			            const sourceData = UIState.doctorHasDraft ? UIState.doctorEditingData.generalIndications : AppState.currentSheet.data.generalIndications;
			            if (key && sourceData.hasOwnProperty(key)) {
			                sourceData[key] = textarea.value;
							// ¡LÍNEA AÑADIDA! Le decimos a la UI que se reajuste.
							Utils.autoResizeTextarea(textarea);
						}
					}
				});

				UI.generalForm.addEventListener('change', (e) => {
					// Sincroniza los checkboxes
					if (e.target.matches('input[type="checkbox"]')) {
						const checkbox = e.target;
						const key = checkbox.dataset.key;
						const subKey = checkbox.dataset.subkey;
			            // ¡CORRECCIÓN CLAVE! Modificamos la copia de trabajo.
			            const sourceData = UIState.doctorHasDraft ? UIState.doctorEditingData.generalIndications : AppState.currentSheet.data.generalIndications;
			            if (key === 'rehabilitacion' && subKey && sourceData.rehabilitacion.hasOwnProperty(subKey)) {
			                sourceData[key][subKey] = checkbox.checked;
						}
					}
				});
				
				// Botón "Agregar" simple
				UI.addNewIndicationButton.addEventListener('click', () => {
					this.addNewIndication();
				});

				// Menú desplegable de "Agregar múltiples"
				UI.addMultipleToggle.addEventListener('click', (e) => {
					e.stopPropagation();
					UI.addMultipleMenu.classList.toggle('hidden');
				});

				// Botón "Agregar múltiples" dentro del menú
				UI.openBulkModalBtn.addEventListener('click', () => {
					UI.addMultipleMenu.classList.add('hidden');
					UI.bulkTextarea.value = '';
					UI.bulkCount.textContent = '0';
					UI.bulkModal.classList.remove('hidden');
				});

				// Lógica del modal de "Agregar múltiples"
				const hideBulkModal = () => {
					UI.bulkModal.classList.add('hidden');
				};
				UI.bulkCancel.addEventListener('click', hideBulkModal);
				UI.bulkModal.addEventListener('click', (e) => {
					if (e.target === UI.bulkModal) {
						hideBulkModal();
					}
				});

				UI.bulkTextarea.addEventListener('input', () => {
					const lines = UI.bulkTextarea.value.split(/\r?\n/).filter(s => s.trim().length > 0);
					UI.bulkCount.textContent = String(lines.length);
				});

				UI.bulkAdd.addEventListener('click', () => {
					const lines = UI.bulkTextarea.value.split(/\r?\n/).filter(s => s.trim().length > 0);
					if (lines.length === 0) {
						hideBulkModal();
						return;
					}

				    // ¡LÓGICA CORREGIDA! Determinamos la fuente de datos correcta.
				    const targetArray = UIState.doctorHasDraft 
				        ? UIState.doctorEditingData.pharmacologicalIndications 
				        : AppState.currentSheet.data.pharmacologicalIndications;
				
				    let nextId = targetArray.length > 0
				        ? Math.max(...targetArray.map(i => i.id)) + 1
				        : 1;

					const newItems = lines.map(text => ({
						id: nextId++,
						indication: text,
						route: null,
						schedules: '',
						schedulesButtons: [],
						status: Config.INDICATION_STATUS.DRAFT,
				        administered: {},
				        sosHistory: []
					}));

				    targetArray.push(...newItems);
				
				    if (UIState.doctorHasDraft) {
				        UI.render();
				    } else {
				        AppState.updateCurrentSheetData({});
				    }
					UI.showToast(`Se agregaron ${newItems.length} indicaciones`);
					hideBulkModal();
				});
				
				UI.pharmacologicalIndicationsTable.addEventListener('input', (e) => {
					// Comprobamos si el evento se originó en un textarea de indicación
					if (e.target.matches('textarea[data-field="indication"]')) {
						const textarea = e.target;
						const row = textarea.closest('tr');
						if (!row) return;

						const indicationId = parseInt(row.dataset.id);
			            // ¡CORRECCIÓN CLAVE! Modificamos la copia de trabajo.
			            const sourceData = UIState.doctorHasDraft ? UIState.doctorEditingData.pharmacologicalIndications : AppState.currentSheet.data.pharmacologicalIndications;
			            const indication = sourceData.find(ind => ind.id === indicationId);

						if (indication) {
							// Sincronizamos el valor del textarea con la propiedad 'indication' en el AppState.
							indication.indication = textarea.value;
							
							// Opcional pero recomendado: auto-redimensionar mientras se escribe.
							Utils.autoResizeTextarea(textarea);

							// Nota: No necesitamos llamar a saveCurrentSheet() en cada tecleo.
							// El estado en memoria está actualizado y se guardará al autorizar.
						}
					}
				});
				
				UI.pharmacologicalIndicationsTable.addEventListener('change', (e) => {
					// Comprobamos si el evento se originó en un radio button de vía
					if (e.target.matches('input[type="radio"][name^="route-"]')) {
						const radio = e.target;
						const row = radio.closest('tr');
						if (!row) return;

						const indicationId = parseInt(row.dataset.id);
						// ¡CORRECCIÓN CLAVE! Modificamos la copia de trabajo.
						const sourceData = UIState.doctorHasDraft ? UIState.doctorEditingData.pharmacologicalIndications : AppState.currentSheet.data.pharmacologicalIndications;
						const indication = sourceData.find(ind => ind.id === indicationId);

						if (indication) {
							// Sincronizamos el valor del radio button seleccionado con la propiedad 'route' en el AppState.
							indication.route = radio.value;
							
							// Nota: No necesitamos llamar a saveCurrentSheet() aquí.
							// El estado en memoria está actualizado y se guardará al autorizar.
						}
					}
				});
				
				UI.correctionModal.addEventListener('click', (e) => {
					const target = e.target;
					// Lógica para seleccionar botones de estado
				    const statusButton = target.closest('#correction-status-buttons button');
				    if (statusButton) {
				        // Quitamos la clase de selección de ambos botones
				        UI.correctionStatusButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('selected', 'correction-status-button'));
				        // Y la añadimos solo al que fue presionado
				        statusButton.classList.add('selected', 'correction-status-button');
						UI.correctionReasonsContainer.classList.toggle('hidden', statusButton.dataset.status !== 'not-done');					
				        // ¡CORRECCIÓN CLAVE! Si no es "No Administrado", limpiamos la selección de razón.
				        if (!isNotDone) {
				            UI.correctionReasonsContainer.querySelectorAll('.reason-button.selected').forEach(btn => btn.classList.remove('selected'));
				        }
						
					}
					// Lógica para seleccionar botones de razón
					if (target.closest('.reason-button')) {
						UI.correctionReasonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
						target.closest('.reason-button').classList.add('selected');
					}
					// Lógica para seleccionar botones de razón de corrección
					if (target.closest('.correction-reason-button')) {
						UI.correctionReasonButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
						target.closest('.correction-reason-button').classList.add('selected');
					}
				});

				UI.correctionModalCancelBtn.addEventListener('click', () => {
				    // Ahora solo necesitamos llamar a la función hide, que se encarga de todo.
				    UI.hideCorrectionModal();
				});
				
				UI.correctionModalSaveBtn.addEventListener('click', () => {
				    // El botón de guardado ahora puede ser para corregir o para borrar
				    if (UI.correctionModalSaveBtn.textContent.includes('Borrado')) {
				        const reason = UI.correctionReasonButtons.querySelector('.selected')?.dataset.correctionReason;
				        if (!reason) {
				            return UI.showInfoModal('Campo Requerido', 'Por favor, seleccione un motivo para el borrado.');
				        }
				        this.deleteAdminRecord(reason);
				    } else {
				        this.saveCorrection();
				    }
				});
				
				UI.correctionModalDeleteBtn.addEventListener('click', () => {
				    UI.setCorrectionModalMode('delete');
				});
				
				UI.correctionModalBackBtn.addEventListener('click', () => {
				    UI.setCorrectionModalMode('correct');
				});
				
			    // Listener para el nuevo modal de edición de horario
			    UI.editScheduleCancelBtn.addEventListener('click', () => UI.hideEditScheduleModal());
			    UI.editScheduleSaveBtn.addEventListener('click', () => this.saveScheduleEdit());
			    UI.editScheduleDeleteBtn.addEventListener('click', () => this.deleteSingleSchedule());	
			
				document.addEventListener('keydown', (e) => {
					// --- Lógica para la tecla Escape ---
					if (e.key === 'Escape') {
						if (UI.reasonModal.classList.contains('visible')) {
							UI.hideReasonModal();
							if (UI.scheduleModalButton) UI.showScheduleModal(UI.scheduleModalButton);
						} else if (UI.infoModal.classList.contains('visible')) {
							UI.hideInfoModal();
						} else if (UI.scheduleModal.classList.contains('visible')) {
							UI.hideScheduleModal();
						} else if (UI.tooltip.classList.contains('visible')) {
							UI.hideTooltip();
						}
						return;
					}

					// --- Lógica para la tecla Enter ---
					if (e.key === 'Enter') {
						const activeElement = document.activeElement;

						// Prioridad 1: Manejar los modales
						if (UI.reasonModal.classList.contains('visible')) {
							e.preventDefault();
							UI.reasonModalSaveBtn.click();
							return;
						}
						if (UI.infoModal.classList.contains('visible')) {
							e.preventDefault();
							UI.hideInfoModal();
							return;
						}

						// Prioridad 2: Manejar el salto de línea con Ctrl+Enter
						if (e.ctrlKey && activeElement.tagName === 'TEXTAREA') {
							e.preventDefault();
							const textarea = activeElement;
							const start = textarea.selectionStart;
							const end = textarea.selectionEnd;
							textarea.value = textarea.value.substring(0, start) + "\n" + textarea.value.substring(end);
							textarea.selectionStart = textarea.selectionEnd = start + 1;
							Utils.autoResizeTextarea(textarea);
							return;
						}

						// Prioridad 3: Navegación entre textareas de HORARIOS para la Enfermera
				        // El selector busca cualquier input con la clase .schedule-input que esté visible.
				        if (activeElement.matches('.schedule-input:not([style*="display: none"])')) {
				            this.navigateWithEnter(e, '.schedule-input:not([style*="display: none"])');
				            return;
				        }

						// Prioridad 4: Navegación entre textareas de INDICACIONES para el Médico
				        // También refactorizamos esta parte para usar la nueva función de ayuda.
				        if (activeElement.matches('.indication-textarea, #ghost-textarea')) {
				            const selector = '.indication-textarea, #ghost-textarea';
				            this.navigateWithEnter(e, selector);
				        }
					}
				});

				document.addEventListener('click', (e) => {
					if (UI.infoModal.classList.contains('visible') || UI.reasonModal.classList.contains('visible')) return;
					if (UI.scheduleModal.classList.contains('visible')) {
						const isClickInside = UI.scheduleModal.contains(e.target) || (UI.scheduleModalButton && UI.scheduleModalButton.contains(e.target));
						if (!isClickInside) UI.hideScheduleModal();
					}
					
				    // ¡CORRECCIÓN CLAVE! Lógica para resetear el desbloqueo al hacer clic fuera.
				    if (UIState.unlockedScheduleId && !e.target.closest('.schedule-button')) {
						UI.clearUnlockedState();
				        <!-- // Comprobamos si el clic fue DENTRO de un botón de horario. -->
				        <!-- // Si lo fue, la lógica de handleScheduleClick se encargará. -->
				        <!-- // Si fue FUERA, reseteamos el estado. -->
				        <!-- const clickedOnAScheduleButton = e.target.closest('.schedule-button'); -->
				        <!-- if (!clickedOnAScheduleButton) { -->
				            <!-- UIState.unlockedScheduleId = null; -->
				            <!-- UI.render(); // Forzamos un re-render para quitar el borde. -->
				        <!-- } -->
				    }
				}, true);

				UI.scheduleModal.addEventListener('click', (e) => {
					if (e.target.closest('.admin-done')) {
						if (!Utils.validateDateTime(UI.adminDateInput.value, UI.adminTimeInput.value)) {
							return UI.showInfoModal('Error de Validación', 'No se puede seleccionar una fecha u hora futura.');
						}
						const { indicationId, scheduleId } = UIState.selectedSchedule;
				        const newState = { status: 'done', reason: null, observations: '', adminTime: UI.adminTimeInput.value, adminDate: UI.adminDateInput.value };
				        
				        const actionType = scheduleId === 'SOS' ? Config.LOG_ACTIONS.ADMINISTER_SOS_MED : Config.LOG_ACTIONS.ADMINISTER_MED;
				        this.logChange(actionType, { indicationId, scheduleId, newState });
				
				        AppState.updateIndicationStatus(indicationId, scheduleId, newState);
						
						UI.showToast('Registro guardado exitosamente');
						UI.hideScheduleModal();
					}
					if (e.target.closest('.admin-not-done')) {
						if (!Utils.validateDateTime(UI.adminDateInput.value, UI.adminTimeInput.value)) {
							return UI.showInfoModal('Error de Validación', 'No se puede seleccionar una fecha u hora futura.');
						}
						if (UI.cleanupPopover) {
							UI.cleanupPopover();
							UI.cleanupPopover = null;
						}
						UI.scheduleModal.classList.remove('visible');
						UI.showReasonModal();
					}
				});

				UI.reasonModal.addEventListener('click', (e) => {
					const target = e.target;
					if (target.closest('.reason-btn')) {
						const reasonButton = target.closest('.reason-btn');
						debugger;
						const reasonText = reasonButton.dataset.reason;
						UI.reasonModal.querySelectorAll('.reason-btn').forEach(btn => btn.classList.remove('selected'));
						reasonButton.classList.add('selected');
						UI.reasonModalTextarea.value = reasonText === 'Otro...' ? '' : reasonText;
						UI.reasonModalTextarea.focus();
					}
					if (target.closest('#reason-modal-save-btn')) {
						const reasonAndObs = UI.reasonModalTextarea.value;
						if (reasonAndObs.trim() === '') {
							UI.showInfoModal('Error de Validación', 'Debe ingresar una razón para no administrar el medicamento.');
							UI.reasonModalTextarea.classList.add('input-error');
							setTimeout(() => UI.reasonModalTextarea.classList.remove('input-error'), 500);
							return;
						}
						const { indicationId, scheduleId } = UIState.selectedSchedule;
						
				        const newState = { status: 'not-done', reason: reasonAndObs.trim(), observations: reasonAndObs.trim(), adminTime: UI.adminTimeInput.value, adminDate: UI.adminDateInput.value };
				
				        const actionType = scheduleId === 'SOS' ? Config.LOG_ACTIONS.ADMINISTER_SOS_MED : Config.LOG_ACTIONS.ADMINISTER_MED;
				        this.logChange(actionType, { indicationId, scheduleId, newState });
				
				        AppState.updateIndicationStatus(indicationId, scheduleId, newState);
						
						UI.hideReasonModal();
						UI.showToast('Registro guardado exitosamente');
						UI.hideScheduleModal();
					}
					if (target.closest('#reason-modal-cancel-btn')) {
						UI.hideReasonModal();
						if (UI.scheduleModalButton) UI.showScheduleModal(UI.scheduleModalButton);
					}
				});

				UI.infoModal.addEventListener('click', (e) => {
					if (e.target === UI.infoModal || e.target.closest('#info-modal-close-btn')) {
						UI.hideInfoModal();
					}
				});
				
				UI.verbalIndicationsSection.addEventListener('click', (e) => {
					const validateButton = e.target.closest('.validate-verbal');
					if (validateButton) {
						const indicationId = parseInt(validateButton.dataset.id);
						this.processVerbalIndication(indicationId, 'validated');
						return;
					}

					const rejectButton = e.target.closest('.reject-verbal');
					if (rejectButton) {
						const indicationId = parseInt(rejectButton.dataset.id);
						this.processVerbalIndication(indicationId, 'rejected');
					}
				});

			
				// --- FUNCIÓN DE APOYO PARA CREAR TEXTO DE TOOLTIP ---
				const buildTooltipText = (element) => {
					const explicitTooltipText = element.dataset.tooltipText;
					if (explicitTooltipText) return explicitTooltipText;
					
			        const indicationId = parseInt(element.dataset.indicationId);
			        const scheduleId = element.dataset.scheduleId;
			        const sourceData = UIState.nurseEditingMode ? UIState.nurseEditingData : AppState.currentSheet.data.pharmacologicalIndications;
			        const indication = sourceData.find(ind => ind.id === indicationId);
			        if (!indication) return null;
			
			        // ¡LÓGICA NUEVA! Comprobamos si este horario tiene un historial de correcciones.
			        const originalAdminData = indication.administered ? indication.administered[scheduleId] : null;
			        if (originalAdminData && originalAdminData.isCorrected) {
			            return Utils.formatCorrectionHistoryTooltip(originalAdminData);
			        }
					
					const obs = element.dataset.observations;
					const rsn = element.dataset.reason;
					const time = element.dataset.adminTime;
					const date = element.dataset.adminDate;
					const history = element.dataset.history;
		
					if (history) {
						let historyHtml = '<b>Administraciones Anteriores:</b><br>';
						const entries = history.split(',');
						historyHtml += entries.map(entry => {
							const [entryDate, entryTime] = entry.split(' ');
							if (!entryDate || !entryTime) return '';
							const [year, month, day] = entryDate.split('-');
							return `&bull; ${day}/${month}/${year.slice(-2)} ${entryTime}`;
						}).join('<br>');
						return historyHtml;
					}
		
					if (obs || rsn || time || date) {
						let text = '';
						if (date && time) {
							const [year, month, day] = date.split('-');
							text += `<b>${day}/${month}/${year.slice(-2)} ${time}</b>`;
						}
						if (rsn) text += `${text ? '<br>' : ''}<b>Razón:</b> ${rsn}`;
						if (obs) text += `${text ? '<br>' : ''}<b>Obs:</b> ${obs}`;
						return text;
					}
					
					if (element.classList.contains('ring-2')) {
						return "Haz clic de nuevo para abrir el modal de corrección";
					}
		
			        // ¡LÓGICA AÑADIDA!
			        // Si ninguna de las condiciones anteriores se cumplió, significa que es un
			        // botón sin registro. Mostramos el mensaje por defecto.
			        // Excluimos los wrappers de huérfanos que no tienen datos.
			        if (!element.classList.contains('tooltip-wrapper')) {
			            return "Sin administraciones asociadas";
			        }
			
			        return null;
				};
		
				UI.pharmacologicalIndicationsTable.addEventListener('mouseover', (e) => {
					const target = e.target.closest('.schedule-button, .tooltip-wrapper');
					if (target) {
						const text = buildTooltipText(target);
						if (text) {
							UI.showTooltip(target, text);
						}
					}
				});
		
				UI.pharmacologicalIndicationsTable.addEventListener('mouseout', (e) => {
					const target = e.target.closest('.schedule-button, .tooltip-wrapper');
					if (target) {
						UI.hideTooltip();
					}
				});

				UI.pharmacologicalIndicationsTable.addEventListener('click', (e) => {
					// Caso 1: Clic en un botón de horario
					if (e.target.closest('.schedule-button')) {
						this.handleScheduleClick(e);
						return;
					}

					// Caso 2: Clic en el ícono de edición de horarios
					if (e.target.closest('.edit-schedules')) {
						const editButton = e.target.closest('.edit-schedules');
						const row = editButton.closest('tr');
						if (!row) return;
						const scheduleInput = row.querySelector('.schedule-input');
						const allScheduleButtons = row.querySelectorAll('.schedule-button');
						allScheduleButtons.forEach(btn => btn.style.display = 'none');
						editButton.style.display = 'none';
						if (scheduleInput) {
							scheduleInput.style.display = 'block';
							scheduleInput.focus();
						}
						return;
					}

					// ¡NUEVO! Caso 3: Clic en el ícono de edición masiva de horarios (Enfermera)
					const editAllButton = e.target.closest('.edit-all-schedules-btn');
					if (editAllButton) {
				        // La lógica ahora es más simple: solo necesitamos marcar la fila
				        // para que el renderizador sepa que debe mostrar el input.
				        const indicationId = parseInt(editAllButton.dataset.indicationId);
				        const indicationInCopy = UIState.nurseEditingData.find(i => i.id === indicationId);
				        if (indicationInCopy) {
				            indicationInCopy.isEditingMassively = true;
				            UI.render();
				            // Usamos setTimeout para asegurar que el focus ocurra después del render
				            setTimeout(() => {
				                const row = UI.pharmacologicalIndicationsTable.querySelector(`tr[data-id="${indicationId}"]`);
				                const input = row?.querySelector('.schedule-input');
				                if (input) {
				                    input.focus();
				                    Utils.moveCursorToEnd(input);
				                }
				            }, 0);
				        }
					}
					
				    // ¡NUEVO! Caso 4: Clic en el botón "+ Añadir Horarios"
				    const addSchedulesButton = e.target.closest('.add-schedules-btn');
				    if (addSchedulesButton) {
				        const cell = addSchedulesButton.closest('td');
				        if (!cell) return;
				
				        const scheduleInput = cell.querySelector('.schedule-input');
				        
				        // Ocultamos el botón "+ Añadir" y mostramos el input
				        addSchedulesButton.classList.add('hidden');
				        if (scheduleInput) {
				            scheduleInput.classList.remove('hidden');
				            scheduleInput.focus();
				        }
				    }
					
					// ¡NUEVO! Caso 5: para el ícono de historial SOS
					const sosHistoryButton = e.target.closest('.sos-history-btn');
					if (sosHistoryButton) {
						const indicationId = parseInt(sosHistoryButton.dataset.indicationId);
						const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
						if (indication) {
							UI.showSosHistoryModal(indication);
						}
					}
					
					    // --- ACCIONES EXCLUSIVAS DEL MÉDICO ---

					// Caso 6: Clic en el ícono de suspender
					const suspendButton = e.target.closest('.suspend-indication');
					if (suspendButton) {
						const indicationId = parseInt(suspendButton.dataset.id);
						UI.showConfirmSuspendModal(indicationId);
						return;
					}

					// Caso 7: Clic en el ícono de eliminar
					const deleteButton = e.target.closest('.delete-indication');
					if (deleteButton) {
						const indicationId = parseInt(deleteButton.dataset.id);
			            // Esta acción solo debe ocurrir en modo de edición
			            if (UIState.doctorHasDraft) {
			                UIState.doctorEditingData.pharmacologicalIndications = UIState.doctorEditingData.pharmacologicalIndications.filter(ind => ind.id !== indicationId);
			                UI.render();
			            }
					}
				});
			
			    // Listeners para el modal de confirmación genérico
			    UI.confirmActionCancelBtn.addEventListener('click', () => {
			        // Si se cancela, reseteamos el valor del select al rol actual
			        if (UIState.pendingAction && UIState.pendingAction.type === 'ROLE_CHANGE') {
			            UI.roleSelect.value = UIState.currentRole;
			        }
			        UI.hideConfirmActionModal();
			    });
			
			    UI.confirmActionDiscardBtn.addEventListener('click', () => {
			        const action = UIState.pendingAction;
			        // Reseteamos el modo de edición correspondiente
			        if (UIState.doctorHasDraft) this.cancelDoctorDraft();
			        if (UIState.nurseEditingMode) this.cancelNurseEditMode(true); // true para descartar
			        
			        UI.hideConfirmActionModal();
			        if (action) action.execute();
			    });
			
			    UI.confirmActionSaveBtn.addEventListener('click', () => {
			        const action = UIState.pendingAction;
			        UI.hideConfirmActionModal();
			
			        // ¡LÓGICA MEJORADA!
			        // Si la acción pendiente tiene una función 'execute', la llamamos.
			        if (action && typeof action.execute === 'function') {
			            // Si es una acción de guardado, esperamos un poco.
			            if (UIState.doctorHasDraft || UIState.nurseEditingMode) {
			                if (UIState.doctorHasDraft) this.authorizeDoctorDraft();
			                if (UIState.nurseEditingMode) this.finalizeNurseEditMode();
			                setTimeout(() => action.execute(), 100);
			            } else {
			                // Si es una acción simple (como la nuestra), la ejecutamos inmediatamente.
			                action.execute();
			            }
			        }
			    });
							
				UI.cancelSuspendButton.addEventListener('click', () => {
					UI.hideConfirmSuspendModal();
				});

			    UI.confirmSuspendButton.addEventListener('click', () => {
			        const idToSuspend = UIState.indicationToSuspend;
			        if (idToSuspend === null) return;
			
			        // ¡LÓGICA CORREGIDA! Determinamos la fuente de datos correcta.
			        const sourceData = UIState.doctorHasDraft 
			            ? UIState.doctorEditingData 
			            : AppState.currentSheet.data;
			
			        const indication = sourceData.pharmacologicalIndications.find(ind => ind.id === idToSuspend);
			        if (indication) {
			            indication.status = Config.INDICATION_STATUS.SUSPENDED;
			        }
			
			        UI.hideConfirmSuspendModal();
			        // Si estamos en modo borrador, solo re-renderizamos. Si no, guardamos.
			        if (UIState.doctorHasDraft) {
			            UI.render();
			        } else {
			            AppState.updateCurrentSheetData({});
			        }
			    });
				
				document.addEventListener('blur', (e) => {
					if (e.target.matches('.schedule-input')) {
						// Pasamos el evento 'e' completo
						this.handleScheduleInputBlur(e.target, e); 
					}
				}, true);
				
		        // --- LISTENERS DE TOOLTIP PARA EL MODAL DE HISTORIAL SOS ---
		        UI.sosHistoryModal.addEventListener('mouseenter', (e) => {
		            // Reutilizamos la misma lógica que para la tabla principal
		            const target = e.target.closest('.tooltip-wrapper');
		            if (target) {
		                const text = buildTooltipText(target);
		                if (text) {
		                    UI.showTooltip(target, text);
		                }
		            }
		        }, true);
		
		        UI.sosHistoryModal.addEventListener('mouseleave', (e) => {
		            const target = e.target.closest('.tooltip-wrapper');
		            if (target) {
		                UI.hideTooltip();
		            }
		        }, true);				
				
		        // Listener para el nuevo modal de historial SOS
		        UI.sosHistoryCloseBtn.addEventListener('click', () => UI.hideSosHistoryModal());
		        UI.sosHistoryModal.addEventListener('click', (e) => {
		            const correctButton = e.target.closest('.correct-sos-btn');
		            if (correctButton) {
		                const indicationId = parseInt(correctButton.dataset.indicationId);
			            const historyId = parseInt(correctButton.dataset.historyId, 10); // Usamos parseInt para asegurar que es un número
			            const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
			            const historyEntry = (indication.sosHistory || []).find(h => h.id === historyId);
			            
			            if (indication && historyEntry) {
			                const proceed = () => UI.showCorrectionModal(indication, historyEntry);
			
			                if (indication.status === Config.INDICATION_STATUS.SUSPENDED) {
			                    UIState.pendingAction = { execute: proceed };
			                    UI.showConfirmActionModal({
			                        title: 'Indicación Suspendida',
			                        message: `Atención: La indicación "${indication.indication}" está suspendida. ¿Deseas continuar con la corrección del registro?`,
			                        cancelText: 'Cancelar',
			                        saveText: 'Continuar'
			                    });
			                } else {
			                    proceed();
			                }
			            }
		                UI.hideSosHistoryModal();
		            }
		        });
			
				UI.actionButton.addEventListener('click', (e) => {
					const target = e.target.closest('button');
					if (!target) return;

					if (UIState.currentRole === 'medico') {
				        debugger;
						if (target.id === 'edit-sheet-btn') this.enterDoctorEditMode();
				        if (target.id === 'authorize-draft-btn') this.authorizeDoctorDraft();
				        if (target.id === 'cancel-draft-btn') this.cancelDoctorDraft();
						return;
					} else if (UIState.currentRole === 'enfermera') {
						if (target.id === 'edit-schedules-btn') UIState.unlockedScheduleId = null, this.enterNurseEditMode();
						if (target.id === 'finalize-edit-btn') this.finalizeNurseEditMode();
						if (target.id === 'cancel-edit-btn') this.cancelNurseEditMode();
					}
				});
				
				// Listener para el nuevo flujo de "Nueva Hoja"
				UI.newSheetBtn.addEventListener('click', () => this.handleNewSheetClick());
				UI.newSheetCancelBtn.addEventListener('click', () => UI.newSheetOptionsModal.classList.add('hidden'));
				UI.newSheetBlankBtn.addEventListener('click', () => this.createNewSheet(false));
				UI.newSheetRepeatBtn.addEventListener('click', () => this.createNewSheet(true));
								
				UI.ghostTextarea.addEventListener('input', (e) => {
					// 1. Comprobamos el bloqueo. Si ya estamos creando una fila, ignoramos este evento.
					if (this.isCreatingRow) {
						return;
					}

					const text = e.target.value;
					if (text.trim().length === 0) return;

					// 2. Activamos el bloqueo para prevenir eventos futuros.
					this.isCreatingRow = true;

					// 3. Creamos la nueva indicación en el estado.
					this.addNewIndication();

					// 4. Esperamos al siguiente ciclo de renderizado.
					setTimeout(() => {
						const textareas = UI.pharmacologicalIndicationsTable.querySelectorAll('textarea.indication-textarea');
						const newTextarea = textareas[textareas.length - 1];

						if (newTextarea) {
							// Transferimos el texto y el foco.
							newTextarea.value = text;
							newTextarea.focus();
							newTextarea.selectionStart = newTextarea.selectionEnd = newTextarea.value.length;
							Utils.autoResizeTextarea(newTextarea);

							// ¡LÍNEA CLAVE! Sincronizamos el estado con el texto visual.
							const row = newTextarea.closest('tr');
							if (row) {
								const indicationId = parseInt(row.dataset.id);
								const indication = AppState.currentSheet.data.pharmacologicalIndications.find(ind => ind.id === indicationId);
								if (indication) {
									indication.indication = text;
								}
							}
						}

						// 6. Limpiamos el textarea fantasma.
						UI.ghostTextarea.value = '';
						
						// 7. ¡CLAVE! Liberamos el bloqueo para que se pueda crear otra fila en el futuro.
						this.isCreatingRow = false;
					}, 0);
				});

			}
		};

		// =================================================================================
		// PUNTO DE ENTRADA DE LA APLICACIÓN
		// =================================================================================
		document.addEventListener('DOMContentLoaded', () => {
			App.init();
		});
    </script>
</body>
</html>